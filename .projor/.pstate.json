{
  "generatedSource": [
    {
      "filename": "README.md",
      "content": "# The Parser Generator\n\nThis repository contains source code for a [ProJor](https://projor.io) template, that can be used to generate _parsers_ for certain languages. These parsers can be used with the [ProJor Languages](https://docs.projor.io/overview/languages.html) feature, to allow for _compact_ and _readable_ representation of a domain model.\n\nLanguage definitions are stored in the [`.projor/languages.pdata.yaml`](.projor/languages.pdata.yaml) file. Parsers for the following languages are generated:\n\n| Name | Description | Parser file | Example file |\n| --- | --- | --- | --- |\n| PagesLang | Language describing pages in an admin site | [pages-lang.parser.js](src/pages-lang.parser.js) | [test.pages](examples/test.pages) |\n| EntityLang | Language describing entities for a CRUD API | [entity-lang.parser.js](src/entity-lang.parser.js) | [test.entities](examples/test.entities) |\n| ServicesLang | Language describing services in a Service Oriented Architecture | [services-lang.parser.js](src/services-lang.parser.js) | [test.services](examples/test.services) |\n| WebServicesLang | Language describing web services | [web-services-lang.parser.js](src/web-services-lang.parser.js) | [test.webservices](examples/test.webservices) |\n\n# License\n\nThe contents of this repository are licensed under [MIT](./LICENSE.md).\n\n[ProJor](https://projor.io) is a product by [SIOCODE](https://siocode.hu), and it is licensed under the [ProJor Free License](https://license.projor.io), or the [ProJor Commercial License](https://license.projor.io).",
      "contentHash": "270250c484ae109624dc932ac1870fd80414b1d35b57fc77adc999749f6d1426",
      "noWriteIfExists": false
    },
    {
      "filename": "src/entity-lang.parser.js",
      "content": "const TOP_LEVEL_ELEMENTS = [\n    {\n        type: \"block\",\n        name: \"entity\",\n        keyword: \"entity\",\n        content: [\n            {\n                type: \"typed-declaration\",\n                name: \"attribute\",\n                keyword: \"col\",\n            },\n            {\n                type: \"typed-declaration\",\n                name: \"association\",\n                keyword: \"join\",\n            },\n            {\n                type: \"typed-declaration\",\n                name: \"reverse_association\",\n                keyword: \"reverse join\",\n            },\n        ],\n    },\n];\n\n// Helper functions\nfunction extractWithinBrackets(text, startIndex, openChar, closeChar) {\n    let content = \"\";\n    let bracketCount = 0;\n    let foundStart = false;\n\n    for (let i = startIndex; i < text.length; i++) {\n        let char = text[i];\n        if (!foundStart) {\n            if (char === openChar) {\n                foundStart = true;\n                bracketCount++;\n            }\n        } else {\n            content += char;\n            if (char === openChar) bracketCount++;\n            if (char === closeChar) bracketCount--;\n            if (bracketCount === 0) {\n                return {\n                    content: content.substring(0, content.length - 1).trim(),\n                    endIndex: i,\n                };\n            }\n        }\n    }\n    return null; // No matching closing bracket found\n}\n\nfunction extractExpressionDetails(\n    inputText,\n    currentIndex,\n    currentLineEndIndex\n) {\n    let annotation = \"\";\n    let generic = \"\";\n    let arguments = \"\";\n    let nextSquareBracketIndex = inputText.indexOf(\"[\", currentIndex);\n    let nextLessThanIndex = inputText.indexOf(\"<\", currentIndex);\n    let nextOpenParenthesisIndex = inputText.indexOf(\"(\", currentIndex);\n\n    if (\n        nextSquareBracketIndex !== -1 &&\n        (nextSquareBracketIndex < currentLineEndIndex ||\n            currentLineEndIndex === -1) &&\n        (nextSquareBracketIndex < nextLessThanIndex ||\n            nextLessThanIndex === -1) &&\n        (nextSquareBracketIndex < nextOpenParenthesisIndex ||\n            nextOpenParenthesisIndex === -1)\n    ) {\n        const annotationContent = extractWithinBrackets(\n            inputText,\n            nextSquareBracketIndex,\n            \"[\",\n            \"]\"\n        );\n        annotation = annotationContent.content;\n\n        if (annotation.includes(\"<\")) {\n            nextLessThanIndex = inputText.indexOf(\n                \"<\",\n                annotationContent.endIndex\n            );\n        }\n        if (annotation.includes(\"(\")) {\n            nextOpenParenthesisIndex = inputText.indexOf(\n                \"(\",\n                annotationContent.endIndex\n            );\n        }\n    }\n\n    if (\n        nextLessThanIndex !== -1 &&\n        (nextLessThanIndex < currentLineEndIndex ||\n            currentLineEndIndex === -1) &&\n        (nextLessThanIndex < nextOpenParenthesisIndex ||\n            nextOpenParenthesisIndex === -1)\n    ) {\n        const genericContent = extractWithinBrackets(\n            inputText,\n            nextLessThanIndex,\n            \"<\",\n            \">\"\n        );\n        generic = genericContent.content;\n\n        if (generic.includes(\"(\")) {\n            nextOpenParenthesisIndex = inputText.indexOf(\n                \"(\",\n                genericContent.endIndex\n            );\n        }\n    }\n\n    if (\n        nextOpenParenthesisIndex !== -1 &&\n        (nextOpenParenthesisIndex < currentLineEndIndex ||\n            currentLineEndIndex === -1)\n    ) {\n        const argumentsContent = extractWithinBrackets(\n            inputText,\n            nextOpenParenthesisIndex,\n            \"(\",\n            \")\"\n        );\n        arguments = argumentsContent.content;\n    }\n\n    return { annotation, generic, arguments };\n}\n\nfunction parse(inputText, topLevelElements = TOP_LEVEL_ELEMENTS) {\n    // There are 4 fundamental structures to parse:\n    // type: block\n    //   The general syntax of blocks is:\n    //     KEYWORD NAME [ ANNOTATION ] < GENERIC > ( ARGUMENTS ) { CONTENT }\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   NAME is a single word, or some words. It may also contain '.', '-', '_' or '#'.\n    //   ANNOTATION is part of a block, surrounded by '[' and ']'. It is arbitrary text between the block characters.\n    //   GENERIC is part of a block, surrounded by '<' and '>'. It is arbitrary text between the block characters.\n    //   ARGUMENTS is part of a block, surrounded by '(' and ')'. It is arbitrary text between the block characters.\n    //   CONTENT is part of a block, surrounded by '{' and '}'. It is arbitrary text between the block characters.\n    // type: property\n    //   The general syntax of properties is:\n    //     KEYWORD VALUE\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   VALUE is any text, up to the end of the line.\n    // type: typed-declaration\n    //   The general syntax of typed-declarations is:\n    //     KEYWORD NAME [ ANNOTATION ] < GENERIC > ( ARGUMENTS ) : TYPE POSTKEYWORD POST\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   NAME is a single word, or some words. It may also contain '.', '-', '_' or '#'.\n    //   ANNOTATION is part of a typed-declaration, surrounded by '[' and ']'. It is arbitrary text between the block characters.\n    //   GENERIC is part of a typed-declaration, surrounded by '<' and '>'. It is arbitrary text between the block characters.\n    //   ARGUMENTS is part of a typed-declaration, surrounded by '(' and ')'. It is arbitrary text between the block characters.\n    //   TYPE is a single word, or some words. The list of valid types is known and fixed.\n    //   POSTKEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   POST is any text, up to the end of the line.\n    // type: declaration\n    //   The general syntax of declarations is:\n    //     KEYWORD NAME [ ANNOTATION ] < GENERIC > ( ARGUMENTS ) POSTKEYWORD POST\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   NAME is a single word, or some words. It may also contain '.', '-', '_' or '#'.\n    //   ANNOTATION is part of a declaration, surrounded by '[' and ']'. It is arbitrary text between the block characters.\n    //   GENERIC is part of a declaration, surrounded by '<' and '>'. It is arbitrary text between the block characters.\n    //   ARGUMENTS is part of a declaration, surrounded by '(' and ')'. It is arbitrary text between the block characters.\n    //   POSTKEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   POST is any text, up to the end of the line.\n    // Comments: Line comments are supported. Any line beginning with '//' is considered a comment. The element starting after one or more comments receives the comment, so it is available for parsing.\n\n    // The parser works like this:\n    //   We have a comment buffer, which is [] by default.\n    //   We have a context (stack), which is created from the top-level elements by default\n    //   We are looking for the first line, that matches a regex in the current context\n    //   Based on the keyword, we decide on the exact type of structure to parse\n    //   In case of blocks ...\n    //     We create a new context from the block, and push it to the stack\n    //     We parse the annotation (if any) ...\n    //       We look for the first '[' character\n    //       We start counting '[' and ']' characters, to find the end of the annotation\n    //       We set ANNOTATION to the trimmed text between the '[' and ']' characters\n    //     We parse the generic (if any) ...\n    //       We look for the first '<' character\n    //       We start counting '<' and '>' characters, to find the end of the generic\n    //       We set GENERIC to the trimmed text between the '<' and '>' characters\n    //     We parse the arguments (if any) ...\n    //       We look for the first '(' character\n    //       We start counting '(' and ')' characters, to find the end of the arguments\n    //       We set ARGUMENTS to the trimmed text between the '(' and ')' characters\n    //     We parse the content (if any) ...\n    //       We look for the first '{' character\n    //       We start counting '{' and '}' characters, to find the end of the content\n    //       We set CONTENT to the trimmed text between the '{' and '}' characters\n    //     We pop the context from the stack\n    //   In case of properties ...\n    //     We parse the value ...\n    //       We set VALUE to the trimmed text after the keyword\n    //   In case of typed-declarations ...\n    //     We parse the annotation (if any) ...\n    //       We look for the first '[' character\n    //       We start counting '[' and ']' characters, to find the end of the annotation\n    //       We set ANNOTATION to the trimmed text between the '[' and ']' characters\n    //     We parse the generic (if any) ...\n    //       We look for the first '<' character\n    //       We start counting '<' and '>' characters, to find the end of the generic\n    //       We set GENERIC to the trimmed text between the '<' and '>' characters\n    //     We parse the arguments (if any) ...\n    //       We look for the first '(' character\n    //       We start counting '(' and ')' characters, to find the end of the arguments\n    //       We set ARGUMENTS to the trimmed text between the '(' and ')' characters\n    //     We parse the type, postkeyword and post parts using a regex\n    //   In case of declarations ...\n    //     We parse the annotation (if any) ...\n    //       We look for the first '[' character\n    //       We start counting '[' and ']' characters, to find the end of the annotation\n    //       We set ANNOTATION to the trimmed text between the '[' and ']' characters\n    //     We parse the generic (if any) ...\n    //       We look for the first '<' character\n    //       We start counting '<' and '>' characters, to find the end of the generic\n    //       We set GENERIC to the trimmed text between the '<' and '>' characters\n    //     We parse the arguments (if any) ...\n    //       We look for the first '(' character\n    //       We start counting '(' and ')' characters, to find the end of the arguments\n    //       We set ARGUMENTS to the trimmed text between the '(' and ')' characters\n    //     We parse the postkeyword and post parts using a regex\n    //   In case of comments ...\n    //     We add the comment to the comment buffer\n    //   In case of empty lines ...\n    //     We ignore the line\n    //   In case of unknown lines ...\n    //     We ignore the line\n\n    let currentIndex = 0;\n    let commentBuffer = [];\n    let results = [];\n\n    while (currentIndex < inputText.length) {\n        const currentLineEndIndex = inputText.indexOf(\"\\n\", currentIndex);\n        if (currentIndex === currentLineEndIndex) {\n            // Empty line\n            currentIndex++;\n            commentBuffer = [];\n            continue;\n        }\n        const currentLine = inputText\n            .substring(\n                currentIndex,\n                currentLineEndIndex === -1\n                    ? inputText.length\n                    : currentLineEndIndex\n            )\n            .trim();\n\n        // Check for comments\n        if (currentLine.startsWith(\"//\")) {\n            commentBuffer.push(currentLine.substring(2).trim());\n            // Move to the next line\n            currentIndex = currentLineEndIndex + 1;\n            continue;\n        }\n\n        const item = { type: \"Unknown\" };\n\n        // Try to match a top level element\n        let matched = false;\n\n        for (let topLevelElement of topLevelElements) {\n            const isThisElement = new RegExp(\n                `^\\\\s*${topLevelElement.keyword}\\\\s*`\n            ).test(currentLine);\n            if (!matched && isThisElement) {\n                if (topLevelElement.type === \"block\") {\n                    // It is a block\n                    // Let's first find where it starts (first '{' character)\n                    const blockStartIndex = inputText.indexOf(\n                        \"{\",\n                        currentIndex\n                    );\n                    if (blockStartIndex === -1) {\n                        // No block start found\n                        break;\n                    }\n                    const blockContent = extractWithinBrackets(\n                        inputText,\n                        blockStartIndex,\n                        \"{\",\n                        \"}\"\n                    );\n\n                    // We should now find the name from the current line\n                    const nameMatch = currentLine.match(\n                        new RegExp(\n                            `\\\\s*${topLevelElement.keyword}\\\\s*([a-zA-Z0-9_\\\\-#\\\\. /:]+)(?:[\\\\[\\\\(<{])`\n                        )\n                    );\n                    const name = nameMatch ? nameMatch[1] : null;\n\n                    let { annotation, generic, arguments } =\n                        extractExpressionDetails(\n                            inputText,\n                            currentIndex,\n                            currentLineEndIndex\n                        );\n\n                    // Now we parse the content\n                    const parsedBlockContent = parse(\n                        blockContent.content,\n                        topLevelElement.content || []\n                    );\n\n                    item.type = topLevelElement.name;\n                    item.name = name.trim();\n                    item.annotation = annotation.trim();\n                    item.generic = generic.trim();\n                    item.arguments = arguments.trim();\n                    item.content = parsedBlockContent;\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    // Add item to results\n                    results.push(item);\n                    matched = true;\n\n                    // Now we move to the line after the block\n                    currentIndex = blockContent.endIndex + 1;\n                } else if (topLevelElement.type === \"property\") {\n                    item.type = topLevelElement.name;\n                    item.value = currentLine\n                        .substring(topLevelElement.keyword.length)\n                        .trim();\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                } else if (topLevelElement.type === \"declaration\") {\n                    // We should now find the name from the current line\n                    const nameMatch = currentLine.match(\n                        new RegExp(\n                            `\\\\s*${topLevelElement.keyword}\\\\s*([a-zA-Z0-9_\\\\-#\\\\. /:]+)(?:[\\\\[\\\\(<{])`\n                        )\n                    );\n                    const name = nameMatch ? nameMatch[1] : null;\n\n                    let { annotation, generic, arguments } =\n                        extractExpressionDetails(\n                            inputText,\n                            currentIndex,\n                            currentLineEndIndex\n                        );\n\n                    if (topLevelElement.postkeyword) {\n                        // See if it has a postkeyword\n                        const postkeywordMatch = currentLine.match(\n                            new RegExp(`\\\\s*${topLevelElement.postkeyword}\\\\s+`)\n                        );\n                        item.postkeyword = topLevelElement.postkeyword;\n                        if (postkeywordMatch) {\n                            item.post = currentLine\n                                .substring(\n                                    postkeywordMatch.index +\n                                        postkeywordMatch[0].length\n                                )\n                                .trim();\n                        }\n                    }\n\n                    item.type = topLevelElement.name;\n                    item.name = name.trim();\n                    item.annotation = annotation.trim();\n                    item.generic = generic.trim();\n                    item.arguments = arguments.trim();\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                } else if (topLevelElement.type === \"typed-declaration\") {\n                    // We should now find the name from the current line\n                    const nameMatch = currentLine.match(\n                        new RegExp(\n                            `\\\\s*${topLevelElement.keyword}\\\\s*([a-zA-Z0-9_\\\\-#\\\\. /:]+)(?:[\\\\[\\\\(<{])?\\\\s*:\\\\s*`\n                        )\n                    );\n                    const name = nameMatch ? nameMatch[1] : null;\n\n                    // Now we should find the type declaration\n                    const typeMatch = currentLine.match(\n                        /\\s*:\\s*([\\w]+)(?:\\s+)?/\n                    );\n                    const type = typeMatch ? typeMatch[1] : null;\n\n                    let { annotation, generic, arguments } =\n                        extractExpressionDetails(\n                            inputText,\n                            currentIndex,\n                            currentLineEndIndex\n                        );\n\n                    if (topLevelElement.poskeyword) {\n                        // See if it has a postkeyword\n                        const postkeywordMatch = currentLine.match(\n                            new RegExp(`\\\\s*${topLevelElement.postkeyword}\\\\s+`)\n                        );\n                        item.postkeyword = topLevelElement.postkeyword;\n                        if (postkeywordMatch) {\n                            item.post = currentLine\n                                .substring(\n                                    postkeywordMatch.index +\n                                        postkeywordMatch[0].length\n                                )\n                                .trim();\n                        }\n                    }\n\n                    item.type = topLevelElement.name;\n                    item.name = name.trim();\n                    item.declaredtype = type.trim();\n                    item.annotation = annotation.trim();\n                    item.generic = generic.trim();\n                    item.arguments = arguments.trim();\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                } else {\n                    item.type = topLevelElement.name;\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                }\n            }\n        }\n\n        if (!matched) {\n            // Move to next line\n            if (currentLineEndIndex === -1) {\n                // End of input\n                currentIndex = inputText.length;\n            } else {\n                currentIndex = currentLineEndIndex + 1;\n            }\n        }\n\n        if (currentIndex === -1) {\n            // End of input\n            break;\n        }\n    }\n\n    return results;\n}\n\nmodule.exports = {\n    parse,\n};\n",
      "contentHash": "b57196c15c9696efcc9ebf9f95f9dbba2cb7aabf34a70c968b2f77af71f0bab0",
      "noWriteIfExists": false
    },
    {
      "filename": "src/pages-lang.parser.js",
      "content": "const TOP_LEVEL_ELEMENTS = [\n    {\n        type: \"block\",\n        name: \"dashboard_block\",\n        keyword: \"dashboard\",\n        content: [\n            {\n                type: \"property\",\n                name: \"title\",\n                keyword: \"title\",\n            },\n            {\n                type: \"property\",\n                name: \"message\",\n                keyword: \"message\",\n            },\n            {\n                type: \"declaration\",\n                name: \"pre_action\",\n                keyword: \"pre action\",\n                postkeyword: \"goes to\",\n            },\n            {\n                type: \"declaration\",\n                name: \"post_action\",\n                keyword: \"post action\",\n                postkeyword: \"goes to\",\n            },\n            {\n                type: \"block\",\n                name: \"stat_widget\",\n                keyword: \"stat widget\",\n                content: [],\n            },\n            {\n                type: \"block\",\n                name: \"message_widget\",\n                keyword: \"msg widget\",\n                content: [],\n            },\n            {\n                type: \"block\",\n                name: \"list_widget\",\n                keyword: \"list widget\",\n                content: [\n                    {\n                        type: \"property\",\n                        name: \"item\",\n                        keyword: \"item\",\n                    },\n                ],\n            },\n        ],\n    },\n    {\n        type: \"block\",\n        name: \"list_page_block\",\n        keyword: \"list_page\",\n        content: [\n            {\n                type: \"property\",\n                name: \"title\",\n                keyword: \"title\",\n            },\n            {\n                type: \"property\",\n                name: \"message\",\n                keyword: \"message\",\n            },\n            {\n                type: \"typed-declaration\",\n                name: \"column\",\n                keyword: \"column\",\n                postkeyword: \"example\",\n            },\n            {\n                type: \"declaration\",\n                name: \"pre_action\",\n                keyword: \"pre action\",\n                postkeyword: \"goes to\",\n            },\n            {\n                type: \"declaration\",\n                name: \"post_action\",\n                keyword: \"post action\",\n                postkeyword: \"goes to\",\n            },\n            {\n                type: \"declaration\",\n                name: \"item_action\",\n                keyword: \"item action\",\n                postkeyword: \"goes to\",\n            },\n        ],\n    },\n    {\n        type: \"block\",\n        name: \"edit_page_block\",\n        keyword: \"edit_page\",\n        content: [\n            {\n                type: \"property\",\n                name: \"title\",\n                keyword: \"title\",\n            },\n            {\n                type: \"property\",\n                name: \"message\",\n                keyword: \"message\",\n            },\n            {\n                type: \"typed-declaration\",\n                name: \"field\",\n                keyword: \"field\",\n                postkeyword: \"example\",\n            },\n            {\n                type: \"declaration\",\n                name: \"pre_action\",\n                keyword: \"pre action\",\n                postkeyword: \"goes to\",\n            },\n            {\n                type: \"declaration\",\n                name: \"post_action\",\n                keyword: \"post action\",\n                postkeyword: \"goes to\",\n            },\n        ],\n    },\n];\n\n// Helper functions\nfunction extractWithinBrackets(text, startIndex, openChar, closeChar) {\n    let content = \"\";\n    let bracketCount = 0;\n    let foundStart = false;\n\n    for (let i = startIndex; i < text.length; i++) {\n        let char = text[i];\n        if (!foundStart) {\n            if (char === openChar) {\n                foundStart = true;\n                bracketCount++;\n            }\n        } else {\n            content += char;\n            if (char === openChar) bracketCount++;\n            if (char === closeChar) bracketCount--;\n            if (bracketCount === 0) {\n                return {\n                    content: content.substring(0, content.length - 1).trim(),\n                    endIndex: i,\n                };\n            }\n        }\n    }\n    return null; // No matching closing bracket found\n}\n\nfunction extractExpressionDetails(\n    inputText,\n    currentIndex,\n    currentLineEndIndex\n) {\n    let annotation = \"\";\n    let generic = \"\";\n    let arguments = \"\";\n    let nextSquareBracketIndex = inputText.indexOf(\"[\", currentIndex);\n    let nextLessThanIndex = inputText.indexOf(\"<\", currentIndex);\n    let nextOpenParenthesisIndex = inputText.indexOf(\"(\", currentIndex);\n\n    if (\n        nextSquareBracketIndex !== -1 &&\n        (nextSquareBracketIndex < currentLineEndIndex ||\n            currentLineEndIndex === -1) &&\n        (nextSquareBracketIndex < nextLessThanIndex ||\n            nextLessThanIndex === -1) &&\n        (nextSquareBracketIndex < nextOpenParenthesisIndex ||\n            nextOpenParenthesisIndex === -1)\n    ) {\n        const annotationContent = extractWithinBrackets(\n            inputText,\n            nextSquareBracketIndex,\n            \"[\",\n            \"]\"\n        );\n        annotation = annotationContent.content;\n\n        if (annotation.includes(\"<\")) {\n            nextLessThanIndex = inputText.indexOf(\n                \"<\",\n                annotationContent.endIndex\n            );\n        }\n        if (annotation.includes(\"(\")) {\n            nextOpenParenthesisIndex = inputText.indexOf(\n                \"(\",\n                annotationContent.endIndex\n            );\n        }\n    }\n\n    if (\n        nextLessThanIndex !== -1 &&\n        (nextLessThanIndex < currentLineEndIndex ||\n            currentLineEndIndex === -1) &&\n        (nextLessThanIndex < nextOpenParenthesisIndex ||\n            nextOpenParenthesisIndex === -1)\n    ) {\n        const genericContent = extractWithinBrackets(\n            inputText,\n            nextLessThanIndex,\n            \"<\",\n            \">\"\n        );\n        generic = genericContent.content;\n\n        if (generic.includes(\"(\")) {\n            nextOpenParenthesisIndex = inputText.indexOf(\n                \"(\",\n                genericContent.endIndex\n            );\n        }\n    }\n\n    if (\n        nextOpenParenthesisIndex !== -1 &&\n        (nextOpenParenthesisIndex < currentLineEndIndex ||\n            currentLineEndIndex === -1)\n    ) {\n        const argumentsContent = extractWithinBrackets(\n            inputText,\n            nextOpenParenthesisIndex,\n            \"(\",\n            \")\"\n        );\n        arguments = argumentsContent.content;\n    }\n\n    return { annotation, generic, arguments };\n}\n\nfunction parse(inputText, topLevelElements = TOP_LEVEL_ELEMENTS) {\n    // There are 4 fundamental structures to parse:\n    // type: block\n    //   The general syntax of blocks is:\n    //     KEYWORD NAME [ ANNOTATION ] < GENERIC > ( ARGUMENTS ) { CONTENT }\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   NAME is a single word, or some words. It may also contain '.', '-', '_' or '#'.\n    //   ANNOTATION is part of a block, surrounded by '[' and ']'. It is arbitrary text between the block characters.\n    //   GENERIC is part of a block, surrounded by '<' and '>'. It is arbitrary text between the block characters.\n    //   ARGUMENTS is part of a block, surrounded by '(' and ')'. It is arbitrary text between the block characters.\n    //   CONTENT is part of a block, surrounded by '{' and '}'. It is arbitrary text between the block characters.\n    // type: property\n    //   The general syntax of properties is:\n    //     KEYWORD VALUE\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   VALUE is any text, up to the end of the line.\n    // type: typed-declaration\n    //   The general syntax of typed-declarations is:\n    //     KEYWORD NAME [ ANNOTATION ] < GENERIC > ( ARGUMENTS ) : TYPE POSTKEYWORD POST\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   NAME is a single word, or some words. It may also contain '.', '-', '_' or '#'.\n    //   ANNOTATION is part of a typed-declaration, surrounded by '[' and ']'. It is arbitrary text between the block characters.\n    //   GENERIC is part of a typed-declaration, surrounded by '<' and '>'. It is arbitrary text between the block characters.\n    //   ARGUMENTS is part of a typed-declaration, surrounded by '(' and ')'. It is arbitrary text between the block characters.\n    //   TYPE is a single word, or some words. The list of valid types is known and fixed.\n    //   POSTKEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   POST is any text, up to the end of the line.\n    // type: declaration\n    //   The general syntax of declarations is:\n    //     KEYWORD NAME [ ANNOTATION ] < GENERIC > ( ARGUMENTS ) POSTKEYWORD POST\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   NAME is a single word, or some words. It may also contain '.', '-', '_' or '#'.\n    //   ANNOTATION is part of a declaration, surrounded by '[' and ']'. It is arbitrary text between the block characters.\n    //   GENERIC is part of a declaration, surrounded by '<' and '>'. It is arbitrary text between the block characters.\n    //   ARGUMENTS is part of a declaration, surrounded by '(' and ')'. It is arbitrary text between the block characters.\n    //   POSTKEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   POST is any text, up to the end of the line.\n    // Comments: Line comments are supported. Any line beginning with '//' is considered a comment. The element starting after one or more comments receives the comment, so it is available for parsing.\n\n    // The parser works like this:\n    //   We have a comment buffer, which is [] by default.\n    //   We have a context (stack), which is created from the top-level elements by default\n    //   We are looking for the first line, that matches a regex in the current context\n    //   Based on the keyword, we decide on the exact type of structure to parse\n    //   In case of blocks ...\n    //     We create a new context from the block, and push it to the stack\n    //     We parse the annotation (if any) ...\n    //       We look for the first '[' character\n    //       We start counting '[' and ']' characters, to find the end of the annotation\n    //       We set ANNOTATION to the trimmed text between the '[' and ']' characters\n    //     We parse the generic (if any) ...\n    //       We look for the first '<' character\n    //       We start counting '<' and '>' characters, to find the end of the generic\n    //       We set GENERIC to the trimmed text between the '<' and '>' characters\n    //     We parse the arguments (if any) ...\n    //       We look for the first '(' character\n    //       We start counting '(' and ')' characters, to find the end of the arguments\n    //       We set ARGUMENTS to the trimmed text between the '(' and ')' characters\n    //     We parse the content (if any) ...\n    //       We look for the first '{' character\n    //       We start counting '{' and '}' characters, to find the end of the content\n    //       We set CONTENT to the trimmed text between the '{' and '}' characters\n    //     We pop the context from the stack\n    //   In case of properties ...\n    //     We parse the value ...\n    //       We set VALUE to the trimmed text after the keyword\n    //   In case of typed-declarations ...\n    //     We parse the annotation (if any) ...\n    //       We look for the first '[' character\n    //       We start counting '[' and ']' characters, to find the end of the annotation\n    //       We set ANNOTATION to the trimmed text between the '[' and ']' characters\n    //     We parse the generic (if any) ...\n    //       We look for the first '<' character\n    //       We start counting '<' and '>' characters, to find the end of the generic\n    //       We set GENERIC to the trimmed text between the '<' and '>' characters\n    //     We parse the arguments (if any) ...\n    //       We look for the first '(' character\n    //       We start counting '(' and ')' characters, to find the end of the arguments\n    //       We set ARGUMENTS to the trimmed text between the '(' and ')' characters\n    //     We parse the type, postkeyword and post parts using a regex\n    //   In case of declarations ...\n    //     We parse the annotation (if any) ...\n    //       We look for the first '[' character\n    //       We start counting '[' and ']' characters, to find the end of the annotation\n    //       We set ANNOTATION to the trimmed text between the '[' and ']' characters\n    //     We parse the generic (if any) ...\n    //       We look for the first '<' character\n    //       We start counting '<' and '>' characters, to find the end of the generic\n    //       We set GENERIC to the trimmed text between the '<' and '>' characters\n    //     We parse the arguments (if any) ...\n    //       We look for the first '(' character\n    //       We start counting '(' and ')' characters, to find the end of the arguments\n    //       We set ARGUMENTS to the trimmed text between the '(' and ')' characters\n    //     We parse the postkeyword and post parts using a regex\n    //   In case of comments ...\n    //     We add the comment to the comment buffer\n    //   In case of empty lines ...\n    //     We ignore the line\n    //   In case of unknown lines ...\n    //     We ignore the line\n\n    let currentIndex = 0;\n    let commentBuffer = [];\n    let results = [];\n\n    while (currentIndex < inputText.length) {\n        const currentLineEndIndex = inputText.indexOf(\"\\n\", currentIndex);\n        if (currentIndex === currentLineEndIndex) {\n            // Empty line\n            currentIndex++;\n            commentBuffer = [];\n            continue;\n        }\n        const currentLine = inputText\n            .substring(\n                currentIndex,\n                currentLineEndIndex === -1\n                    ? inputText.length\n                    : currentLineEndIndex\n            )\n            .trim();\n\n        // Check for comments\n        if (currentLine.startsWith(\"//\")) {\n            commentBuffer.push(currentLine.substring(2).trim());\n            // Move to the next line\n            currentIndex = currentLineEndIndex + 1;\n            continue;\n        }\n\n        const item = { type: \"Unknown\" };\n\n        // Try to match a top level element\n        let matched = false;\n\n        for (let topLevelElement of topLevelElements) {\n            const isThisElement = new RegExp(\n                `^\\\\s*${topLevelElement.keyword}\\\\s*`\n            ).test(currentLine);\n            if (!matched && isThisElement) {\n                if (topLevelElement.type === \"block\") {\n                    // It is a block\n                    // Let's first find where it starts (first '{' character)\n                    const blockStartIndex = inputText.indexOf(\n                        \"{\",\n                        currentIndex\n                    );\n                    if (blockStartIndex === -1) {\n                        // No block start found\n                        break;\n                    }\n                    const blockContent = extractWithinBrackets(\n                        inputText,\n                        blockStartIndex,\n                        \"{\",\n                        \"}\"\n                    );\n\n                    // We should now find the name from the current line\n                    const nameMatch = currentLine.match(\n                        new RegExp(\n                            `\\\\s*${topLevelElement.keyword}\\\\s*([a-zA-Z0-9_\\\\-#\\\\. /:]+)(?:[\\\\[\\\\(<{])`\n                        )\n                    );\n                    const name = nameMatch ? nameMatch[1] : null;\n\n                    let { annotation, generic, arguments } =\n                        extractExpressionDetails(\n                            inputText,\n                            currentIndex,\n                            currentLineEndIndex\n                        );\n\n                    // Now we parse the content\n                    const parsedBlockContent = parse(\n                        blockContent.content,\n                        topLevelElement.content || []\n                    );\n\n                    item.type = topLevelElement.name;\n                    item.name = name.trim();\n                    item.annotation = annotation.trim();\n                    item.generic = generic.trim();\n                    item.arguments = arguments.trim();\n                    item.content = parsedBlockContent;\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    // Add item to results\n                    results.push(item);\n                    matched = true;\n\n                    // Now we move to the line after the block\n                    currentIndex = blockContent.endIndex + 1;\n                } else if (topLevelElement.type === \"property\") {\n                    item.type = topLevelElement.name;\n                    item.value = currentLine\n                        .substring(topLevelElement.keyword.length)\n                        .trim();\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                } else if (topLevelElement.type === \"declaration\") {\n                    // We should now find the name from the current line\n                    const nameMatch = currentLine.match(\n                        new RegExp(\n                            `\\\\s*${topLevelElement.keyword}\\\\s*([a-zA-Z0-9_\\\\-#\\\\. /:]+)(?:[\\\\[\\\\(<{])`\n                        )\n                    );\n                    const name = nameMatch ? nameMatch[1] : null;\n\n                    let { annotation, generic, arguments } =\n                        extractExpressionDetails(\n                            inputText,\n                            currentIndex,\n                            currentLineEndIndex\n                        );\n\n                    if (topLevelElement.postkeyword) {\n                        // See if it has a postkeyword\n                        const postkeywordMatch = currentLine.match(\n                            new RegExp(`\\\\s*${topLevelElement.postkeyword}\\\\s+`)\n                        );\n                        item.postkeyword = topLevelElement.postkeyword;\n                        if (postkeywordMatch) {\n                            item.post = currentLine\n                                .substring(\n                                    postkeywordMatch.index +\n                                        postkeywordMatch[0].length\n                                )\n                                .trim();\n                        }\n                    }\n\n                    item.type = topLevelElement.name;\n                    item.name = name.trim();\n                    item.annotation = annotation.trim();\n                    item.generic = generic.trim();\n                    item.arguments = arguments.trim();\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                } else if (topLevelElement.type === \"typed-declaration\") {\n                    // We should now find the name from the current line\n                    const nameMatch = currentLine.match(\n                        new RegExp(\n                            `\\\\s*${topLevelElement.keyword}\\\\s*([a-zA-Z0-9_\\\\-#\\\\. /:]+)(?:[\\\\[\\\\(<{])?\\\\s*:\\\\s*`\n                        )\n                    );\n                    const name = nameMatch ? nameMatch[1] : null;\n\n                    // Now we should find the type declaration\n                    const typeMatch = currentLine.match(\n                        /\\s*:\\s*([\\w]+)(?:\\s+)?/\n                    );\n                    const type = typeMatch ? typeMatch[1] : null;\n\n                    let { annotation, generic, arguments } =\n                        extractExpressionDetails(\n                            inputText,\n                            currentIndex,\n                            currentLineEndIndex\n                        );\n\n                    if (topLevelElement.poskeyword) {\n                        // See if it has a postkeyword\n                        const postkeywordMatch = currentLine.match(\n                            new RegExp(`\\\\s*${topLevelElement.postkeyword}\\\\s+`)\n                        );\n                        item.postkeyword = topLevelElement.postkeyword;\n                        if (postkeywordMatch) {\n                            item.post = currentLine\n                                .substring(\n                                    postkeywordMatch.index +\n                                        postkeywordMatch[0].length\n                                )\n                                .trim();\n                        }\n                    }\n\n                    item.type = topLevelElement.name;\n                    item.name = name.trim();\n                    item.declaredtype = type.trim();\n                    item.annotation = annotation.trim();\n                    item.generic = generic.trim();\n                    item.arguments = arguments.trim();\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                } else {\n                    item.type = topLevelElement.name;\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                }\n            }\n        }\n\n        if (!matched) {\n            // Move to next line\n            if (currentLineEndIndex === -1) {\n                // End of input\n                currentIndex = inputText.length;\n            } else {\n                currentIndex = currentLineEndIndex + 1;\n            }\n        }\n\n        if (currentIndex === -1) {\n            // End of input\n            break;\n        }\n    }\n\n    return results;\n}\n\nmodule.exports = {\n    parse,\n};\n",
      "contentHash": "72de3b62a5dde66619e3ef6d406034bef7467897b10420670c5c43625e6872a0",
      "noWriteIfExists": false
    },
    {
      "filename": "src/services-lang.parser.js",
      "content": "const TOP_LEVEL_ELEMENTS = [\n    {\n        type: \"block\",\n        name: \"dto\",\n        keyword: \"dto\",\n        content: [\n            {\n                type: \"typed-declaration\",\n                name: \"field\",\n                keyword: \"\\\\+\",\n            },\n        ],\n    },\n    {\n        type: \"block\",\n        name: \"service\",\n        keyword: \"service\",\n        content: [\n            {\n                type: \"declaration\",\n                name: \"operation\",\n                keyword: \"\\\\+\",\n                postkeyword: \"->\",\n            },\n        ],\n    },\n];\n\n// Helper functions\nfunction extractWithinBrackets(text, startIndex, openChar, closeChar) {\n    let content = \"\";\n    let bracketCount = 0;\n    let foundStart = false;\n\n    for (let i = startIndex; i < text.length; i++) {\n        let char = text[i];\n        if (!foundStart) {\n            if (char === openChar) {\n                foundStart = true;\n                bracketCount++;\n            }\n        } else {\n            content += char;\n            if (char === openChar) bracketCount++;\n            if (char === closeChar) bracketCount--;\n            if (bracketCount === 0) {\n                return {\n                    content: content.substring(0, content.length - 1).trim(),\n                    endIndex: i,\n                };\n            }\n        }\n    }\n    return null; // No matching closing bracket found\n}\n\nfunction extractExpressionDetails(\n    inputText,\n    currentIndex,\n    currentLineEndIndex\n) {\n    let annotation = \"\";\n    let generic = \"\";\n    let arguments = \"\";\n    let nextSquareBracketIndex = inputText.indexOf(\"[\", currentIndex);\n    let nextLessThanIndex = inputText.indexOf(\"<\", currentIndex);\n    let nextOpenParenthesisIndex = inputText.indexOf(\"(\", currentIndex);\n\n    if (\n        nextSquareBracketIndex !== -1 &&\n        (nextSquareBracketIndex < currentLineEndIndex ||\n            currentLineEndIndex === -1) &&\n        (nextSquareBracketIndex < nextLessThanIndex ||\n            nextLessThanIndex === -1) &&\n        (nextSquareBracketIndex < nextOpenParenthesisIndex ||\n            nextOpenParenthesisIndex === -1)\n    ) {\n        const annotationContent = extractWithinBrackets(\n            inputText,\n            nextSquareBracketIndex,\n            \"[\",\n            \"]\"\n        );\n        annotation = annotationContent.content;\n\n        if (annotation.includes(\"<\")) {\n            nextLessThanIndex = inputText.indexOf(\n                \"<\",\n                annotationContent.endIndex\n            );\n        }\n        if (annotation.includes(\"(\")) {\n            nextOpenParenthesisIndex = inputText.indexOf(\n                \"(\",\n                annotationContent.endIndex\n            );\n        }\n    }\n\n    if (\n        nextLessThanIndex !== -1 &&\n        (nextLessThanIndex < currentLineEndIndex ||\n            currentLineEndIndex === -1) &&\n        (nextLessThanIndex < nextOpenParenthesisIndex ||\n            nextOpenParenthesisIndex === -1)\n    ) {\n        const genericContent = extractWithinBrackets(\n            inputText,\n            nextLessThanIndex,\n            \"<\",\n            \">\"\n        );\n        generic = genericContent.content;\n\n        if (generic.includes(\"(\")) {\n            nextOpenParenthesisIndex = inputText.indexOf(\n                \"(\",\n                genericContent.endIndex\n            );\n        }\n    }\n\n    if (\n        nextOpenParenthesisIndex !== -1 &&\n        (nextOpenParenthesisIndex < currentLineEndIndex ||\n            currentLineEndIndex === -1)\n    ) {\n        const argumentsContent = extractWithinBrackets(\n            inputText,\n            nextOpenParenthesisIndex,\n            \"(\",\n            \")\"\n        );\n        arguments = argumentsContent.content;\n    }\n\n    return { annotation, generic, arguments };\n}\n\nfunction parse(inputText, topLevelElements = TOP_LEVEL_ELEMENTS) {\n    // There are 4 fundamental structures to parse:\n    // type: block\n    //   The general syntax of blocks is:\n    //     KEYWORD NAME [ ANNOTATION ] < GENERIC > ( ARGUMENTS ) { CONTENT }\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   NAME is a single word, or some words. It may also contain '.', '-', '_' or '#'.\n    //   ANNOTATION is part of a block, surrounded by '[' and ']'. It is arbitrary text between the block characters.\n    //   GENERIC is part of a block, surrounded by '<' and '>'. It is arbitrary text between the block characters.\n    //   ARGUMENTS is part of a block, surrounded by '(' and ')'. It is arbitrary text between the block characters.\n    //   CONTENT is part of a block, surrounded by '{' and '}'. It is arbitrary text between the block characters.\n    // type: property\n    //   The general syntax of properties is:\n    //     KEYWORD VALUE\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   VALUE is any text, up to the end of the line.\n    // type: typed-declaration\n    //   The general syntax of typed-declarations is:\n    //     KEYWORD NAME [ ANNOTATION ] < GENERIC > ( ARGUMENTS ) : TYPE POSTKEYWORD POST\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   NAME is a single word, or some words. It may also contain '.', '-', '_' or '#'.\n    //   ANNOTATION is part of a typed-declaration, surrounded by '[' and ']'. It is arbitrary text between the block characters.\n    //   GENERIC is part of a typed-declaration, surrounded by '<' and '>'. It is arbitrary text between the block characters.\n    //   ARGUMENTS is part of a typed-declaration, surrounded by '(' and ')'. It is arbitrary text between the block characters.\n    //   TYPE is a single word, or some words. The list of valid types is known and fixed.\n    //   POSTKEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   POST is any text, up to the end of the line.\n    // type: declaration\n    //   The general syntax of declarations is:\n    //     KEYWORD NAME [ ANNOTATION ] < GENERIC > ( ARGUMENTS ) POSTKEYWORD POST\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   NAME is a single word, or some words. It may also contain '.', '-', '_' or '#'.\n    //   ANNOTATION is part of a declaration, surrounded by '[' and ']'. It is arbitrary text between the block characters.\n    //   GENERIC is part of a declaration, surrounded by '<' and '>'. It is arbitrary text between the block characters.\n    //   ARGUMENTS is part of a declaration, surrounded by '(' and ')'. It is arbitrary text between the block characters.\n    //   POSTKEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   POST is any text, up to the end of the line.\n    // Comments: Line comments are supported. Any line beginning with '//' is considered a comment. The element starting after one or more comments receives the comment, so it is available for parsing.\n\n    // The parser works like this:\n    //   We have a comment buffer, which is [] by default.\n    //   We have a context (stack), which is created from the top-level elements by default\n    //   We are looking for the first line, that matches a regex in the current context\n    //   Based on the keyword, we decide on the exact type of structure to parse\n    //   In case of blocks ...\n    //     We create a new context from the block, and push it to the stack\n    //     We parse the annotation (if any) ...\n    //       We look for the first '[' character\n    //       We start counting '[' and ']' characters, to find the end of the annotation\n    //       We set ANNOTATION to the trimmed text between the '[' and ']' characters\n    //     We parse the generic (if any) ...\n    //       We look for the first '<' character\n    //       We start counting '<' and '>' characters, to find the end of the generic\n    //       We set GENERIC to the trimmed text between the '<' and '>' characters\n    //     We parse the arguments (if any) ...\n    //       We look for the first '(' character\n    //       We start counting '(' and ')' characters, to find the end of the arguments\n    //       We set ARGUMENTS to the trimmed text between the '(' and ')' characters\n    //     We parse the content (if any) ...\n    //       We look for the first '{' character\n    //       We start counting '{' and '}' characters, to find the end of the content\n    //       We set CONTENT to the trimmed text between the '{' and '}' characters\n    //     We pop the context from the stack\n    //   In case of properties ...\n    //     We parse the value ...\n    //       We set VALUE to the trimmed text after the keyword\n    //   In case of typed-declarations ...\n    //     We parse the annotation (if any) ...\n    //       We look for the first '[' character\n    //       We start counting '[' and ']' characters, to find the end of the annotation\n    //       We set ANNOTATION to the trimmed text between the '[' and ']' characters\n    //     We parse the generic (if any) ...\n    //       We look for the first '<' character\n    //       We start counting '<' and '>' characters, to find the end of the generic\n    //       We set GENERIC to the trimmed text between the '<' and '>' characters\n    //     We parse the arguments (if any) ...\n    //       We look for the first '(' character\n    //       We start counting '(' and ')' characters, to find the end of the arguments\n    //       We set ARGUMENTS to the trimmed text between the '(' and ')' characters\n    //     We parse the type, postkeyword and post parts using a regex\n    //   In case of declarations ...\n    //     We parse the annotation (if any) ...\n    //       We look for the first '[' character\n    //       We start counting '[' and ']' characters, to find the end of the annotation\n    //       We set ANNOTATION to the trimmed text between the '[' and ']' characters\n    //     We parse the generic (if any) ...\n    //       We look for the first '<' character\n    //       We start counting '<' and '>' characters, to find the end of the generic\n    //       We set GENERIC to the trimmed text between the '<' and '>' characters\n    //     We parse the arguments (if any) ...\n    //       We look for the first '(' character\n    //       We start counting '(' and ')' characters, to find the end of the arguments\n    //       We set ARGUMENTS to the trimmed text between the '(' and ')' characters\n    //     We parse the postkeyword and post parts using a regex\n    //   In case of comments ...\n    //     We add the comment to the comment buffer\n    //   In case of empty lines ...\n    //     We ignore the line\n    //   In case of unknown lines ...\n    //     We ignore the line\n\n    let currentIndex = 0;\n    let commentBuffer = [];\n    let results = [];\n\n    while (currentIndex < inputText.length) {\n        const currentLineEndIndex = inputText.indexOf(\"\\n\", currentIndex);\n        if (currentIndex === currentLineEndIndex) {\n            // Empty line\n            currentIndex++;\n            commentBuffer = [];\n            continue;\n        }\n        const currentLine = inputText\n            .substring(\n                currentIndex,\n                currentLineEndIndex === -1\n                    ? inputText.length\n                    : currentLineEndIndex\n            )\n            .trim();\n\n        // Check for comments\n        if (currentLine.startsWith(\"//\")) {\n            commentBuffer.push(currentLine.substring(2).trim());\n            // Move to the next line\n            currentIndex = currentLineEndIndex + 1;\n            continue;\n        }\n\n        const item = { type: \"Unknown\" };\n\n        // Try to match a top level element\n        let matched = false;\n\n        for (let topLevelElement of topLevelElements) {\n            const isThisElement = new RegExp(\n                `^\\\\s*${topLevelElement.keyword}\\\\s*`\n            ).test(currentLine);\n            if (!matched && isThisElement) {\n                if (topLevelElement.type === \"block\") {\n                    // It is a block\n                    // Let's first find where it starts (first '{' character)\n                    const blockStartIndex = inputText.indexOf(\n                        \"{\",\n                        currentIndex\n                    );\n                    if (blockStartIndex === -1) {\n                        // No block start found\n                        break;\n                    }\n                    const blockContent = extractWithinBrackets(\n                        inputText,\n                        blockStartIndex,\n                        \"{\",\n                        \"}\"\n                    );\n\n                    // We should now find the name from the current line\n                    const nameMatch = currentLine.match(\n                        new RegExp(\n                            `\\\\s*${topLevelElement.keyword}\\\\s*([a-zA-Z0-9_\\\\-#\\\\. /:]+)(?:[\\\\[\\\\(<{])`\n                        )\n                    );\n                    const name = nameMatch ? nameMatch[1] : null;\n\n                    let { annotation, generic, arguments } =\n                        extractExpressionDetails(\n                            inputText,\n                            currentIndex,\n                            currentLineEndIndex\n                        );\n\n                    // Now we parse the content\n                    const parsedBlockContent = parse(\n                        blockContent.content,\n                        topLevelElement.content || []\n                    );\n\n                    item.type = topLevelElement.name;\n                    item.name = name.trim();\n                    item.annotation = annotation.trim();\n                    item.generic = generic.trim();\n                    item.arguments = arguments.trim();\n                    item.content = parsedBlockContent;\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    // Add item to results\n                    results.push(item);\n                    matched = true;\n\n                    // Now we move to the line after the block\n                    currentIndex = blockContent.endIndex + 1;\n                } else if (topLevelElement.type === \"property\") {\n                    item.type = topLevelElement.name;\n                    item.value = currentLine\n                        .substring(topLevelElement.keyword.length)\n                        .trim();\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                } else if (topLevelElement.type === \"declaration\") {\n                    // We should now find the name from the current line\n                    const nameMatch = currentLine.match(\n                        new RegExp(\n                            `\\\\s*${topLevelElement.keyword}\\\\s*([a-zA-Z0-9_\\\\-#\\\\. /:]+)(?:[\\\\[\\\\(<{])`\n                        )\n                    );\n                    const name = nameMatch ? nameMatch[1] : null;\n\n                    let { annotation, generic, arguments } =\n                        extractExpressionDetails(\n                            inputText,\n                            currentIndex,\n                            currentLineEndIndex\n                        );\n\n                    if (topLevelElement.postkeyword) {\n                        // See if it has a postkeyword\n                        const postkeywordMatch = currentLine.match(\n                            new RegExp(`\\\\s*${topLevelElement.postkeyword}\\\\s+`)\n                        );\n                        item.postkeyword = topLevelElement.postkeyword;\n                        if (postkeywordMatch) {\n                            item.post = currentLine\n                                .substring(\n                                    postkeywordMatch.index +\n                                        postkeywordMatch[0].length\n                                )\n                                .trim();\n                        }\n                    }\n\n                    item.type = topLevelElement.name;\n                    item.name = name.trim();\n                    item.annotation = annotation.trim();\n                    item.generic = generic.trim();\n                    item.arguments = arguments.trim();\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                } else if (topLevelElement.type === \"typed-declaration\") {\n                    // We should now find the name from the current line\n                    const nameMatch = currentLine.match(\n                        new RegExp(\n                            `\\\\s*${topLevelElement.keyword}\\\\s*([a-zA-Z0-9_\\\\-#\\\\. /:]+)(?:[\\\\[\\\\(<{])?\\\\s*:\\\\s*`\n                        )\n                    );\n                    const name = nameMatch ? nameMatch[1] : null;\n\n                    // Now we should find the type declaration\n                    const typeMatch = currentLine.match(\n                        /\\s*:\\s*([\\w]+)(?:\\s+)?/\n                    );\n                    const type = typeMatch ? typeMatch[1] : null;\n\n                    let { annotation, generic, arguments } =\n                        extractExpressionDetails(\n                            inputText,\n                            currentIndex,\n                            currentLineEndIndex\n                        );\n\n                    if (topLevelElement.poskeyword) {\n                        // See if it has a postkeyword\n                        const postkeywordMatch = currentLine.match(\n                            new RegExp(`\\\\s*${topLevelElement.postkeyword}\\\\s+`)\n                        );\n                        item.postkeyword = topLevelElement.postkeyword;\n                        if (postkeywordMatch) {\n                            item.post = currentLine\n                                .substring(\n                                    postkeywordMatch.index +\n                                        postkeywordMatch[0].length\n                                )\n                                .trim();\n                        }\n                    }\n\n                    item.type = topLevelElement.name;\n                    item.name = name.trim();\n                    item.declaredtype = type.trim();\n                    item.annotation = annotation.trim();\n                    item.generic = generic.trim();\n                    item.arguments = arguments.trim();\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                } else {\n                    item.type = topLevelElement.name;\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                }\n            }\n        }\n\n        if (!matched) {\n            // Move to next line\n            if (currentLineEndIndex === -1) {\n                // End of input\n                currentIndex = inputText.length;\n            } else {\n                currentIndex = currentLineEndIndex + 1;\n            }\n        }\n\n        if (currentIndex === -1) {\n            // End of input\n            break;\n        }\n    }\n\n    return results;\n}\n\nmodule.exports = {\n    parse,\n};\n",
      "contentHash": "38f2c55acd962fd1e1508b3e3bb086ed4fa3a140da06edeada1ad614951e31ae",
      "noWriteIfExists": false
    },
    {
      "filename": "src/web-services-lang.parser.js",
      "content": "const TOP_LEVEL_ELEMENTS = [\n    {\n        type: \"block\",\n        name: \"dto\",\n        keyword: \"dto\",\n        content: [\n            {\n                type: \"typed-declaration\",\n                name: \"field\",\n                keyword: \"\\\\+\",\n            },\n        ],\n    },\n    {\n        type: \"block\",\n        name: \"service\",\n        keyword: \"service\",\n        content: [\n            {\n                type: \"declaration\",\n                name: \"get_operation\",\n                keyword: \"GET\",\n                postkeyword: \"->\",\n            },\n            {\n                type: \"declaration\",\n                name: \"post_operation\",\n                keyword: \"POST\",\n                postkeyword: \"->\",\n            },\n            {\n                type: \"declaration\",\n                name: \"put_operation\",\n                keyword: \"PUT\",\n                postkeyword: \"->\",\n            },\n            {\n                type: \"declaration\",\n                name: \"delete_operation\",\n                keyword: \"DELETE\",\n                postkeyword: \"->\",\n            },\n            {\n                type: \"declaration\",\n                name: \"patch_operation\",\n                keyword: \"PATCH\",\n                postkeyword: \"->\",\n            },\n            {\n                type: \"declaration\",\n                name: \"head_operation\",\n                keyword: \"HEAD\",\n                postkeyword: \"->\",\n            },\n            {\n                type: \"declaration\",\n                name: \"options_operation\",\n                keyword: \"OPTIONS\",\n                postkeyword: \"->\",\n            },\n        ],\n    },\n];\n\n// Helper functions\nfunction extractWithinBrackets(text, startIndex, openChar, closeChar) {\n    let content = \"\";\n    let bracketCount = 0;\n    let foundStart = false;\n\n    for (let i = startIndex; i < text.length; i++) {\n        let char = text[i];\n        if (!foundStart) {\n            if (char === openChar) {\n                foundStart = true;\n                bracketCount++;\n            }\n        } else {\n            content += char;\n            if (char === openChar) bracketCount++;\n            if (char === closeChar) bracketCount--;\n            if (bracketCount === 0) {\n                return {\n                    content: content.substring(0, content.length - 1).trim(),\n                    endIndex: i,\n                };\n            }\n        }\n    }\n    return null; // No matching closing bracket found\n}\n\nfunction extractExpressionDetails(\n    inputText,\n    currentIndex,\n    currentLineEndIndex\n) {\n    let annotation = \"\";\n    let generic = \"\";\n    let arguments = \"\";\n    let nextSquareBracketIndex = inputText.indexOf(\"[\", currentIndex);\n    let nextLessThanIndex = inputText.indexOf(\"<\", currentIndex);\n    let nextOpenParenthesisIndex = inputText.indexOf(\"(\", currentIndex);\n\n    if (\n        nextSquareBracketIndex !== -1 &&\n        (nextSquareBracketIndex < currentLineEndIndex ||\n            currentLineEndIndex === -1) &&\n        (nextSquareBracketIndex < nextLessThanIndex ||\n            nextLessThanIndex === -1) &&\n        (nextSquareBracketIndex < nextOpenParenthesisIndex ||\n            nextOpenParenthesisIndex === -1)\n    ) {\n        const annotationContent = extractWithinBrackets(\n            inputText,\n            nextSquareBracketIndex,\n            \"[\",\n            \"]\"\n        );\n        annotation = annotationContent.content;\n\n        if (annotation.includes(\"<\")) {\n            nextLessThanIndex = inputText.indexOf(\n                \"<\",\n                annotationContent.endIndex\n            );\n        }\n        if (annotation.includes(\"(\")) {\n            nextOpenParenthesisIndex = inputText.indexOf(\n                \"(\",\n                annotationContent.endIndex\n            );\n        }\n    }\n\n    if (\n        nextLessThanIndex !== -1 &&\n        (nextLessThanIndex < currentLineEndIndex ||\n            currentLineEndIndex === -1) &&\n        (nextLessThanIndex < nextOpenParenthesisIndex ||\n            nextOpenParenthesisIndex === -1)\n    ) {\n        const genericContent = extractWithinBrackets(\n            inputText,\n            nextLessThanIndex,\n            \"<\",\n            \">\"\n        );\n        generic = genericContent.content;\n\n        if (generic.includes(\"(\")) {\n            nextOpenParenthesisIndex = inputText.indexOf(\n                \"(\",\n                genericContent.endIndex\n            );\n        }\n    }\n\n    if (\n        nextOpenParenthesisIndex !== -1 &&\n        (nextOpenParenthesisIndex < currentLineEndIndex ||\n            currentLineEndIndex === -1)\n    ) {\n        const argumentsContent = extractWithinBrackets(\n            inputText,\n            nextOpenParenthesisIndex,\n            \"(\",\n            \")\"\n        );\n        arguments = argumentsContent.content;\n    }\n\n    return { annotation, generic, arguments };\n}\n\nfunction parse(inputText, topLevelElements = TOP_LEVEL_ELEMENTS) {\n    // There are 4 fundamental structures to parse:\n    // type: block\n    //   The general syntax of blocks is:\n    //     KEYWORD NAME [ ANNOTATION ] < GENERIC > ( ARGUMENTS ) { CONTENT }\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   NAME is a single word, or some words. It may also contain '.', '-', '_' or '#'.\n    //   ANNOTATION is part of a block, surrounded by '[' and ']'. It is arbitrary text between the block characters.\n    //   GENERIC is part of a block, surrounded by '<' and '>'. It is arbitrary text between the block characters.\n    //   ARGUMENTS is part of a block, surrounded by '(' and ')'. It is arbitrary text between the block characters.\n    //   CONTENT is part of a block, surrounded by '{' and '}'. It is arbitrary text between the block characters.\n    // type: property\n    //   The general syntax of properties is:\n    //     KEYWORD VALUE\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   VALUE is any text, up to the end of the line.\n    // type: typed-declaration\n    //   The general syntax of typed-declarations is:\n    //     KEYWORD NAME [ ANNOTATION ] < GENERIC > ( ARGUMENTS ) : TYPE POSTKEYWORD POST\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   NAME is a single word, or some words. It may also contain '.', '-', '_' or '#'.\n    //   ANNOTATION is part of a typed-declaration, surrounded by '[' and ']'. It is arbitrary text between the block characters.\n    //   GENERIC is part of a typed-declaration, surrounded by '<' and '>'. It is arbitrary text between the block characters.\n    //   ARGUMENTS is part of a typed-declaration, surrounded by '(' and ')'. It is arbitrary text between the block characters.\n    //   TYPE is a single word, or some words. The list of valid types is known and fixed.\n    //   POSTKEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   POST is any text, up to the end of the line.\n    // type: declaration\n    //   The general syntax of declarations is:\n    //     KEYWORD NAME [ ANNOTATION ] < GENERIC > ( ARGUMENTS ) POSTKEYWORD POST\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   NAME is a single word, or some words. It may also contain '.', '-', '_' or '#'.\n    //   ANNOTATION is part of a declaration, surrounded by '[' and ']'. It is arbitrary text between the block characters.\n    //   GENERIC is part of a declaration, surrounded by '<' and '>'. It is arbitrary text between the block characters.\n    //   ARGUMENTS is part of a declaration, surrounded by '(' and ')'. It is arbitrary text between the block characters.\n    //   POSTKEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   POST is any text, up to the end of the line.\n    // Comments: Line comments are supported. Any line beginning with '//' is considered a comment. The element starting after one or more comments receives the comment, so it is available for parsing.\n\n    // The parser works like this:\n    //   We have a comment buffer, which is [] by default.\n    //   We have a context (stack), which is created from the top-level elements by default\n    //   We are looking for the first line, that matches a regex in the current context\n    //   Based on the keyword, we decide on the exact type of structure to parse\n    //   In case of blocks ...\n    //     We create a new context from the block, and push it to the stack\n    //     We parse the annotation (if any) ...\n    //       We look for the first '[' character\n    //       We start counting '[' and ']' characters, to find the end of the annotation\n    //       We set ANNOTATION to the trimmed text between the '[' and ']' characters\n    //     We parse the generic (if any) ...\n    //       We look for the first '<' character\n    //       We start counting '<' and '>' characters, to find the end of the generic\n    //       We set GENERIC to the trimmed text between the '<' and '>' characters\n    //     We parse the arguments (if any) ...\n    //       We look for the first '(' character\n    //       We start counting '(' and ')' characters, to find the end of the arguments\n    //       We set ARGUMENTS to the trimmed text between the '(' and ')' characters\n    //     We parse the content (if any) ...\n    //       We look for the first '{' character\n    //       We start counting '{' and '}' characters, to find the end of the content\n    //       We set CONTENT to the trimmed text between the '{' and '}' characters\n    //     We pop the context from the stack\n    //   In case of properties ...\n    //     We parse the value ...\n    //       We set VALUE to the trimmed text after the keyword\n    //   In case of typed-declarations ...\n    //     We parse the annotation (if any) ...\n    //       We look for the first '[' character\n    //       We start counting '[' and ']' characters, to find the end of the annotation\n    //       We set ANNOTATION to the trimmed text between the '[' and ']' characters\n    //     We parse the generic (if any) ...\n    //       We look for the first '<' character\n    //       We start counting '<' and '>' characters, to find the end of the generic\n    //       We set GENERIC to the trimmed text between the '<' and '>' characters\n    //     We parse the arguments (if any) ...\n    //       We look for the first '(' character\n    //       We start counting '(' and ')' characters, to find the end of the arguments\n    //       We set ARGUMENTS to the trimmed text between the '(' and ')' characters\n    //     We parse the type, postkeyword and post parts using a regex\n    //   In case of declarations ...\n    //     We parse the annotation (if any) ...\n    //       We look for the first '[' character\n    //       We start counting '[' and ']' characters, to find the end of the annotation\n    //       We set ANNOTATION to the trimmed text between the '[' and ']' characters\n    //     We parse the generic (if any) ...\n    //       We look for the first '<' character\n    //       We start counting '<' and '>' characters, to find the end of the generic\n    //       We set GENERIC to the trimmed text between the '<' and '>' characters\n    //     We parse the arguments (if any) ...\n    //       We look for the first '(' character\n    //       We start counting '(' and ')' characters, to find the end of the arguments\n    //       We set ARGUMENTS to the trimmed text between the '(' and ')' characters\n    //     We parse the postkeyword and post parts using a regex\n    //   In case of comments ...\n    //     We add the comment to the comment buffer\n    //   In case of empty lines ...\n    //     We ignore the line\n    //   In case of unknown lines ...\n    //     We ignore the line\n\n    let currentIndex = 0;\n    let commentBuffer = [];\n    let results = [];\n\n    while (currentIndex < inputText.length) {\n        const currentLineEndIndex = inputText.indexOf(\"\\n\", currentIndex);\n        if (currentIndex === currentLineEndIndex) {\n            // Empty line\n            currentIndex++;\n            commentBuffer = [];\n            continue;\n        }\n        const currentLine = inputText\n            .substring(\n                currentIndex,\n                currentLineEndIndex === -1\n                    ? inputText.length\n                    : currentLineEndIndex\n            )\n            .trim();\n\n        // Check for comments\n        if (currentLine.startsWith(\"//\")) {\n            commentBuffer.push(currentLine.substring(2).trim());\n            // Move to the next line\n            currentIndex = currentLineEndIndex + 1;\n            continue;\n        }\n\n        const item = { type: \"Unknown\" };\n\n        // Try to match a top level element\n        let matched = false;\n\n        for (let topLevelElement of topLevelElements) {\n            const isThisElement = new RegExp(\n                `^\\\\s*${topLevelElement.keyword}\\\\s*`\n            ).test(currentLine);\n            if (!matched && isThisElement) {\n                if (topLevelElement.type === \"block\") {\n                    // It is a block\n                    // Let's first find where it starts (first '{' character)\n                    const blockStartIndex = inputText.indexOf(\n                        \"{\",\n                        currentIndex\n                    );\n                    if (blockStartIndex === -1) {\n                        // No block start found\n                        break;\n                    }\n                    const blockContent = extractWithinBrackets(\n                        inputText,\n                        blockStartIndex,\n                        \"{\",\n                        \"}\"\n                    );\n\n                    // We should now find the name from the current line\n                    const nameMatch = currentLine.match(\n                        new RegExp(\n                            `\\\\s*${topLevelElement.keyword}\\\\s*([a-zA-Z0-9_\\\\-#\\\\. /:]+)(?:[\\\\[\\\\(<{])`\n                        )\n                    );\n                    const name = nameMatch ? nameMatch[1] : null;\n\n                    let { annotation, generic, arguments } =\n                        extractExpressionDetails(\n                            inputText,\n                            currentIndex,\n                            currentLineEndIndex\n                        );\n\n                    // Now we parse the content\n                    const parsedBlockContent = parse(\n                        blockContent.content,\n                        topLevelElement.content || []\n                    );\n\n                    item.type = topLevelElement.name;\n                    item.name = name.trim();\n                    item.annotation = annotation.trim();\n                    item.generic = generic.trim();\n                    item.arguments = arguments.trim();\n                    item.content = parsedBlockContent;\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    // Add item to results\n                    results.push(item);\n                    matched = true;\n\n                    // Now we move to the line after the block\n                    currentIndex = blockContent.endIndex + 1;\n                } else if (topLevelElement.type === \"property\") {\n                    item.type = topLevelElement.name;\n                    item.value = currentLine\n                        .substring(topLevelElement.keyword.length)\n                        .trim();\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                } else if (topLevelElement.type === \"declaration\") {\n                    // We should now find the name from the current line\n                    const nameMatch = currentLine.match(\n                        new RegExp(\n                            `\\\\s*${topLevelElement.keyword}\\\\s*([a-zA-Z0-9_\\\\-#\\\\. /:]+)(?:[\\\\[\\\\(<{])`\n                        )\n                    );\n                    const name = nameMatch ? nameMatch[1] : null;\n\n                    let { annotation, generic, arguments } =\n                        extractExpressionDetails(\n                            inputText,\n                            currentIndex,\n                            currentLineEndIndex\n                        );\n\n                    if (topLevelElement.postkeyword) {\n                        // See if it has a postkeyword\n                        const postkeywordMatch = currentLine.match(\n                            new RegExp(`\\\\s*${topLevelElement.postkeyword}\\\\s+`)\n                        );\n                        item.postkeyword = topLevelElement.postkeyword;\n                        if (postkeywordMatch) {\n                            item.post = currentLine\n                                .substring(\n                                    postkeywordMatch.index +\n                                        postkeywordMatch[0].length\n                                )\n                                .trim();\n                        }\n                    }\n\n                    item.type = topLevelElement.name;\n                    item.name = name.trim();\n                    item.annotation = annotation.trim();\n                    item.generic = generic.trim();\n                    item.arguments = arguments.trim();\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                } else if (topLevelElement.type === \"typed-declaration\") {\n                    // We should now find the name from the current line\n                    const nameMatch = currentLine.match(\n                        new RegExp(\n                            `\\\\s*${topLevelElement.keyword}\\\\s*([a-zA-Z0-9_\\\\-#\\\\. /:]+)(?:[\\\\[\\\\(<{])?\\\\s*:\\\\s*`\n                        )\n                    );\n                    const name = nameMatch ? nameMatch[1] : null;\n\n                    // Now we should find the type declaration\n                    const typeMatch = currentLine.match(\n                        /\\s*:\\s*([\\w]+)(?:\\s+)?/\n                    );\n                    const type = typeMatch ? typeMatch[1] : null;\n\n                    let { annotation, generic, arguments } =\n                        extractExpressionDetails(\n                            inputText,\n                            currentIndex,\n                            currentLineEndIndex\n                        );\n\n                    if (topLevelElement.poskeyword) {\n                        // See if it has a postkeyword\n                        const postkeywordMatch = currentLine.match(\n                            new RegExp(`\\\\s*${topLevelElement.postkeyword}\\\\s+`)\n                        );\n                        item.postkeyword = topLevelElement.postkeyword;\n                        if (postkeywordMatch) {\n                            item.post = currentLine\n                                .substring(\n                                    postkeywordMatch.index +\n                                        postkeywordMatch[0].length\n                                )\n                                .trim();\n                        }\n                    }\n\n                    item.type = topLevelElement.name;\n                    item.name = name.trim();\n                    item.declaredtype = type.trim();\n                    item.annotation = annotation.trim();\n                    item.generic = generic.trim();\n                    item.arguments = arguments.trim();\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                } else {\n                    item.type = topLevelElement.name;\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                }\n            }\n        }\n\n        if (!matched) {\n            // Move to next line\n            if (currentLineEndIndex === -1) {\n                // End of input\n                currentIndex = inputText.length;\n            } else {\n                currentIndex = currentLineEndIndex + 1;\n            }\n        }\n\n        if (currentIndex === -1) {\n            // End of input\n            break;\n        }\n    }\n\n    return results;\n}\n\nmodule.exports = {\n    parse,\n};\n",
      "contentHash": "614bafb342d23198cef1e33279e8c2ede826541be555eadacf043ee1107414f8",
      "noWriteIfExists": false
    },
    {
      "filename": "test/test-entity-lang.js",
      "content": "const { parse } = require(\"../src/entity-lang.parser\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst examplePath = path.join(__dirname, \"../examples/test.entities\");\nconst testContent = fs.readFileSync(examplePath, \"utf8\");\nconst parsedContent = parse(testContent);\n\nconsole.log(JSON.stringify(parsedContent, null, 4));\n",
      "contentHash": "7ae0647920e5f14989b0f2389b9828dc05c18d9dedafa8dedf9ae1a77120cd15",
      "noWriteIfExists": false
    },
    {
      "filename": "test/test-pages-lang.js",
      "content": "const { parse } = require(\"../src/pages-lang.parser\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst examplePath = path.join(__dirname, \"../examples/test.pages\");\nconst testContent = fs.readFileSync(examplePath, \"utf8\");\nconst parsedContent = parse(testContent);\n\nconsole.log(JSON.stringify(parsedContent, null, 4));\n",
      "contentHash": "bd0f5766522bded9cc825511e4e43968e3ba788fe287dfdf54ec2b4f56456e55",
      "noWriteIfExists": false
    },
    {
      "filename": "test/test-services-lang.js",
      "content": "const { parse } = require(\"../src/services-lang.parser\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst examplePath = path.join(__dirname, \"../examples/test.services\");\nconst testContent = fs.readFileSync(examplePath, \"utf8\");\nconst parsedContent = parse(testContent);\n\nconsole.log(JSON.stringify(parsedContent, null, 4));\n",
      "contentHash": "a8ad9a15e5ba502f3187ba7d6cadc40498b44be7f355b2db6e9245ba00b659c2",
      "noWriteIfExists": false
    },
    {
      "filename": "test/test-web-services-lang.js",
      "content": "const { parse } = require(\"../src/web-services-lang.parser\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst examplePath = path.join(__dirname, \"../examples/test.webservices\");\nconst testContent = fs.readFileSync(examplePath, \"utf8\");\nconst parsedContent = parse(testContent);\n\nconsole.log(JSON.stringify(parsedContent, null, 4));\n",
      "contentHash": "cce0723de18ac6d2ad7bcf7e5446b73b8753b752ac56943b0f69ab1ee3255d9a",
      "noWriteIfExists": false
    }
  ]
}