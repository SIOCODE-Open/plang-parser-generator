{
  "generatedSource": [
    {
      "filename": "README.md",
      "content": "# The Parser Generator\n\nThis repository contains source code for a [ProJor](https://projor.io) template, that can be used to generate _parsers_ for certain languages. These parsers can be used with the [ProJor Languages](https://docs.projor.io/overview/languages.html) feature, to allow for _compact_ and _readable_ representation of a domain model.\n\nLanguage definitions are stored in the [`.projor/languages.pdata.yaml`](.projor/languages.pdata.yaml) file. Parsers for the following languages are generated:\n\n| Name | Description | Parser file | Example file |\n| --- | --- | --- | --- |\n| PagesLang | Language describing pages in an admin site | [pages-lang.parser.js](src/pages-lang.parser.js) | [test.pages](examples/test.pages) |\n| EntityLang | Language describing entities for a CRUD API | [entity-lang.parser.js](src/entity-lang.parser.js) | [test.entities](examples/test.entities) |\n",
      "contentHash": "c874abe9edab07b0e9255c333f4620d89cf820edbc5ad6f938d44887f30a2183",
      "noWriteIfExists": false
    },
    {
      "filename": "src/entity-lang.parser.js",
      "content": "const TOP_LEVEL_ELEMENTS = [\n    {\n        type: \"block\",\n        name: \"entity\",\n        keyword: \"entity\",\n        content: [\n            {\n                type: \"typed-declaration\",\n                name: \"attribute\",\n                keyword: \"col\",\n            },\n            {\n                type: \"typed-declaration\",\n                name: \"association\",\n                keyword: \"join\",\n            },\n            {\n                type: \"typed-declaration\",\n                name: \"reverse_association\",\n                keyword: \"reverse join\",\n            },\n        ],\n    },\n];\n\n// Helper functions\nfunction extractWithinBrackets(text, startIndex, openChar, closeChar) {\n    let content = \"\";\n    let bracketCount = 0;\n    let foundStart = false;\n\n    for (let i = startIndex; i < text.length; i++) {\n        let char = text[i];\n        if (!foundStart) {\n            if (char === openChar) {\n                foundStart = true;\n                bracketCount++;\n            }\n        } else {\n            content += char;\n            if (char === openChar) bracketCount++;\n            if (char === closeChar) bracketCount--;\n            if (bracketCount === 0) {\n                return {\n                    content: content.substring(0, content.length - 1).trim(),\n                    endIndex: i,\n                };\n            }\n        }\n    }\n    return null; // No matching closing bracket found\n}\n\nfunction parse(inputText, topLevelElements = TOP_LEVEL_ELEMENTS) {\n    // There are 4 fundamental structures to parse:\n    // type: block\n    //   The general syntax of blocks is:\n    //     KEYWORD NAME [ ANNOTATION ] < GENERIC > ( ARGUMENTS ) { CONTENT }\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   NAME is a single word, or some words. It may also contain '.', '-', '_' or '#'.\n    //   ANNOTATION is part of a block, surrounded by '[' and ']'. It is arbitrary text between the block characters.\n    //   GENERIC is part of a block, surrounded by '<' and '>'. It is arbitrary text between the block characters.\n    //   ARGUMENTS is part of a block, surrounded by '(' and ')'. It is arbitrary text between the block characters.\n    //   CONTENT is part of a block, surrounded by '{' and '}'. It is arbitrary text between the block characters.\n    // type: property\n    //   The general syntax of properties is:\n    //     KEYWORD VALUE\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   VALUE is any text, up to the end of the line.\n    // type: typed-declaration\n    //   The general syntax of typed-declarations is:\n    //     KEYWORD NAME [ ANNOTATION ] < GENERIC > ( ARGUMENTS ) : TYPE POSTKEYWORD POST\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   NAME is a single word, or some words. It may also contain '.', '-', '_' or '#'.\n    //   ANNOTATION is part of a typed-declaration, surrounded by '[' and ']'. It is arbitrary text between the block characters.\n    //   GENERIC is part of a typed-declaration, surrounded by '<' and '>'. It is arbitrary text between the block characters.\n    //   ARGUMENTS is part of a typed-declaration, surrounded by '(' and ')'. It is arbitrary text between the block characters.\n    //   TYPE is a single word, or some words. The list of valid types is known and fixed.\n    //   POSTKEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   POST is any text, up to the end of the line.\n    // type: declaration\n    //   The general syntax of declarations is:\n    //     KEYWORD NAME [ ANNOTATION ] < GENERIC > ( ARGUMENTS ) POSTKEYWORD POST\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   NAME is a single word, or some words. It may also contain '.', '-', '_' or '#'.\n    //   ANNOTATION is part of a declaration, surrounded by '[' and ']'. It is arbitrary text between the block characters.\n    //   GENERIC is part of a declaration, surrounded by '<' and '>'. It is arbitrary text between the block characters.\n    //   ARGUMENTS is part of a declaration, surrounded by '(' and ')'. It is arbitrary text between the block characters.\n    //   POSTKEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   POST is any text, up to the end of the line.\n    // Comments: Line comments are supported. Any line beginning with '//' is considered a comment. The element starting after one or more comments receives the comment, so it is available for parsing.\n\n    // The parser works like this:\n    //   We have a comment buffer, which is [] by default.\n    //   We have a context (stack), which is created from the top-level elements by default\n    //   We are looking for the first line, that matches a regex in the current context\n    //   Based on the keyword, we decide on the exact type of structure to parse\n    //   In case of blocks ...\n    //     We create a new context from the block, and push it to the stack\n    //     We parse the annotation (if any) ...\n    //       We look for the first '[' character\n    //       We start counting '[' and ']' characters, to find the end of the annotation\n    //       We set ANNOTATION to the trimmed text between the '[' and ']' characters\n    //     We parse the generic (if any) ...\n    //       We look for the first '<' character\n    //       We start counting '<' and '>' characters, to find the end of the generic\n    //       We set GENERIC to the trimmed text between the '<' and '>' characters\n    //     We parse the arguments (if any) ...\n    //       We look for the first '(' character\n    //       We start counting '(' and ')' characters, to find the end of the arguments\n    //       We set ARGUMENTS to the trimmed text between the '(' and ')' characters\n    //     We parse the content (if any) ...\n    //       We look for the first '{' character\n    //       We start counting '{' and '}' characters, to find the end of the content\n    //       We set CONTENT to the trimmed text between the '{' and '}' characters\n    //     We pop the context from the stack\n    //   In case of properties ...\n    //     We parse the value ...\n    //       We set VALUE to the trimmed text after the keyword\n    //   In case of typed-declarations ...\n    //     We parse the annotation (if any) ...\n    //       We look for the first '[' character\n    //       We start counting '[' and ']' characters, to find the end of the annotation\n    //       We set ANNOTATION to the trimmed text between the '[' and ']' characters\n    //     We parse the generic (if any) ...\n    //       We look for the first '<' character\n    //       We start counting '<' and '>' characters, to find the end of the generic\n    //       We set GENERIC to the trimmed text between the '<' and '>' characters\n    //     We parse the arguments (if any) ...\n    //       We look for the first '(' character\n    //       We start counting '(' and ')' characters, to find the end of the arguments\n    //       We set ARGUMENTS to the trimmed text between the '(' and ')' characters\n    //     We parse the type, postkeyword and post parts using a regex\n    //   In case of declarations ...\n    //     We parse the annotation (if any) ...\n    //       We look for the first '[' character\n    //       We start counting '[' and ']' characters, to find the end of the annotation\n    //       We set ANNOTATION to the trimmed text between the '[' and ']' characters\n    //     We parse the generic (if any) ...\n    //       We look for the first '<' character\n    //       We start counting '<' and '>' characters, to find the end of the generic\n    //       We set GENERIC to the trimmed text between the '<' and '>' characters\n    //     We parse the arguments (if any) ...\n    //       We look for the first '(' character\n    //       We start counting '(' and ')' characters, to find the end of the arguments\n    //       We set ARGUMENTS to the trimmed text between the '(' and ')' characters\n    //     We parse the postkeyword and post parts using a regex\n    //   In case of comments ...\n    //     We add the comment to the comment buffer\n    //   In case of empty lines ...\n    //     We ignore the line\n    //   In case of unknown lines ...\n    //     We ignore the line\n\n    let currentIndex = 0;\n    let commentBuffer = [];\n    let results = [];\n\n    while (currentIndex < inputText.length) {\n        const currentLineEndIndex = inputText.indexOf(\"\\n\", currentIndex);\n        if (currentIndex === currentLineEndIndex) {\n            // Empty line\n            currentIndex++;\n            commentBuffer = [];\n            continue;\n        }\n        const currentLine = inputText\n            .substring(\n                currentIndex,\n                currentLineEndIndex === -1\n                    ? inputText.length\n                    : currentLineEndIndex\n            )\n            .trim();\n\n        // Check for comments\n        if (currentLine.startsWith(\"//\")) {\n            commentBuffer.push(currentLine.substring(2).trim());\n            // Move to the next line\n            currentIndex = currentLineEndIndex + 1;\n            continue;\n        }\n\n        const item = { type: \"Unknown\" };\n\n        // Try to match a top level element\n        let matched = false;\n\n        for (let topLevelElement of topLevelElements) {\n            const isThisElement = new RegExp(\n                `^\\\\s*${topLevelElement.keyword}\\\\s+`\n            ).test(currentLine);\n            if (!matched && isThisElement) {\n                if (topLevelElement.type === \"block\") {\n                    // It is a block\n                    // Let's first find where it starts (first '{' character)\n                    const blockStartIndex = inputText.indexOf(\n                        \"{\",\n                        currentIndex\n                    );\n                    if (blockStartIndex === -1) {\n                        // No block start found\n                        break;\n                    }\n                    const blockContent = extractWithinBrackets(\n                        inputText,\n                        blockStartIndex,\n                        \"{\",\n                        \"}\"\n                    );\n\n                    // We should now find the name from the current line\n                    const nameMatch = currentLine.match(\n                        new RegExp(\n                            `\\\\s*${topLevelElement.keyword}\\\\s+([a-zA-Z0-9_\\\\-#\\\\. ]+)(?:[\\\\[\\\\(<{])`\n                        )\n                    );\n                    const name = nameMatch ? nameMatch[1] : null;\n\n                    // Now let's see if the block has annotations\n                    // We need to check between currentIndex and blockStartIndex, whether there's a '[' character\n                    // If there is, we should extract the annotation\n                    let annotation = \"\";\n                    const nextSquareBracketIndex = inputText.indexOf(\n                        \"[\",\n                        currentIndex\n                    );\n                    if (\n                        nextSquareBracketIndex !== -1 &&\n                        nextSquareBracketIndex < blockStartIndex\n                    ) {\n                        const annotationContent = extractWithinBrackets(\n                            inputText,\n                            nextSquareBracketIndex,\n                            \"[\",\n                            \"]\"\n                        );\n                        annotation = annotationContent.content;\n                    }\n\n                    // Extract generics\n                    let generic = \"\";\n                    const nextLessThanIndex = inputText.indexOf(\n                        \"<\",\n                        currentIndex\n                    );\n                    if (\n                        nextLessThanIndex !== -1 &&\n                        nextLessThanIndex < blockStartIndex\n                    ) {\n                        const genericContent = extractWithinBrackets(\n                            inputText,\n                            nextLessThanIndex,\n                            \"<\",\n                            \">\"\n                        );\n                        generic = genericContent.content;\n                    }\n\n                    // Extract arguments\n                    let arguments = \"\";\n                    const nextOpenParenthesisIndex = inputText.indexOf(\n                        \"(\",\n                        currentIndex\n                    );\n                    if (\n                        nextOpenParenthesisIndex !== -1 &&\n                        nextOpenParenthesisIndex < blockStartIndex\n                    ) {\n                        const argumentsContent = extractWithinBrackets(\n                            inputText,\n                            nextOpenParenthesisIndex,\n                            \"(\",\n                            \")\"\n                        );\n                        arguments = argumentsContent.content;\n                    }\n\n                    // Now we parse the content\n                    const parsedBlockContent = parse(\n                        blockContent.content,\n                        topLevelElement.content || []\n                    );\n\n                    item.type = topLevelElement.name;\n                    item.name = name.trim();\n                    item.annotation = annotation.trim();\n                    item.generic = generic.trim();\n                    item.arguments = arguments.trim();\n                    item.content = parsedBlockContent;\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    // Add item to results\n                    results.push(item);\n                    matched = true;\n\n                    // Now we move to the line after the block\n                    currentIndex = blockContent.endIndex + 1;\n                } else if (topLevelElement.type === \"property\") {\n                    item.type = topLevelElement.name;\n                    item.value = currentLine\n                        .substring(topLevelElement.keyword.length)\n                        .trim();\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                } else if (topLevelElement.type === \"declaration\") {\n                    // We should now find the name from the current line\n                    const nameMatch = currentLine.match(\n                        new RegExp(\n                            `\\\\s*${topLevelElement.keyword}\\\\s+([a-zA-Z0-9_\\\\-#\\\\. ]+)(?:[\\\\[\\\\(<{])`\n                        )\n                    );\n                    const name = nameMatch ? nameMatch[1] : null;\n\n                    // Now let's see if the declaration has annotations in the current line\n                    // We need to check between currentIndex and currentLineEndIndex, whether there's a '[' character\n                    // If there is, we should extract the annotation\n                    let annotation = \"\";\n                    const nextSquareBracketIndex = inputText.indexOf(\n                        \"[\",\n                        currentIndex\n                    );\n                    if (\n                        nextSquareBracketIndex !== -1 &&\n                        (nextSquareBracketIndex < currentLineEndIndex ||\n                            currentLineEndIndex === -1)\n                    ) {\n                        const annotationContent = extractWithinBrackets(\n                            inputText,\n                            nextSquareBracketIndex,\n                            \"[\",\n                            \"]\"\n                        );\n                        annotation = annotationContent.content;\n                    }\n\n                    // Extract generics\n                    let generic = \"\";\n                    const nextLessThanIndex = inputText.indexOf(\n                        \"<\",\n                        currentIndex\n                    );\n                    if (\n                        nextLessThanIndex !== -1 &&\n                        (nextLessThanIndex < currentLineEndIndex ||\n                            currentLineEndIndex === -1)\n                    ) {\n                        const genericContent = extractWithinBrackets(\n                            inputText,\n                            nextLessThanIndex,\n                            \"<\",\n                            \">\"\n                        );\n                        generic = genericContent.content;\n                    }\n\n                    // Extract arguments\n                    let arguments = \"\";\n                    const nextOpenParenthesisIndex = inputText.indexOf(\n                        \"(\",\n                        currentIndex\n                    );\n                    if (\n                        nextOpenParenthesisIndex !== -1 &&\n                        (nextOpenParenthesisIndex < currentLineEndIndex ||\n                            currentLineEndIndex === -1)\n                    ) {\n                        const argumentsContent = extractWithinBrackets(\n                            inputText,\n                            nextOpenParenthesisIndex,\n                            \"(\",\n                            \")\"\n                        );\n                        arguments = argumentsContent.content;\n                    }\n\n                    // See if it has a postkeyword\n                    const postkeywordMatch = currentLine.match(\n                        new RegExp(`\\\\s*${topLevelElement.postkeyword}\\\\s+`)\n                    );\n                    if (postkeywordMatch) {\n                        item.postkeyword = topLevelElement.postkeyword;\n                        item.post = currentLine\n                            .substring(\n                                postkeywordMatch.index +\n                                    postkeywordMatch[0].length\n                            )\n                            .trim();\n                    }\n\n                    item.type = topLevelElement.name;\n                    item.name = name.trim();\n                    item.annotation = annotation.trim();\n                    item.generic = generic.trim();\n                    item.arguments = arguments.trim();\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                } else if (topLevelElement.type === \"typed-declaration\") {\n                    // We should now find the name from the current line\n                    const nameMatch = currentLine.match(\n                        new RegExp(\n                            `\\\\s*${topLevelElement.keyword}\\\\s+([a-zA-Z0-9_\\\\-#\\\\. ]+)(?:[\\\\[\\\\(<{])?\\\\s*:\\\\s*`\n                        )\n                    );\n                    const name = nameMatch ? nameMatch[1] : null;\n\n                    // Now we should find the type declaration\n                    const typeMatch = currentLine.match(\n                        /\\s*:\\s*([\\w]+)(?:\\s+)?/\n                    );\n                    const type = typeMatch ? typeMatch[1] : null;\n\n                    // Now let's see if the block has annotations\n                    // We need to check between currentIndex and blockStartIndex, whether there's a '[' character\n                    // If there is, we should extract the annotation\n                    let annotation = \"\";\n                    const nextSquareBracketIndex = inputText.indexOf(\n                        \"[\",\n                        currentIndex\n                    );\n                    if (\n                        nextSquareBracketIndex !== -1 &&\n                        (nextSquareBracketIndex < currentLineEndIndex ||\n                            currentLineEndIndex === -1)\n                    ) {\n                        const annotationContent = extractWithinBrackets(\n                            inputText,\n                            nextSquareBracketIndex,\n                            \"[\",\n                            \"]\"\n                        );\n                        annotation = annotationContent.content;\n                    }\n\n                    // Extract generics\n                    let generic = \"\";\n                    const nextLessThanIndex = inputText.indexOf(\n                        \"<\",\n                        currentIndex\n                    );\n                    if (\n                        nextLessThanIndex !== -1 &&\n                        (nextLessThanIndex < currentLineEndIndex ||\n                            currentLineEndIndex === -1)\n                    ) {\n                        const genericContent = extractWithinBrackets(\n                            inputText,\n                            nextLessThanIndex,\n                            \"<\",\n                            \">\"\n                        );\n                        generic = genericContent.content;\n                    }\n\n                    // Extract arguments\n                    let arguments = \"\";\n                    const nextOpenParenthesisIndex = inputText.indexOf(\n                        \"(\",\n                        currentIndex\n                    );\n                    if (\n                        nextOpenParenthesisIndex !== -1 &&\n                        (nextOpenParenthesisIndex < currentLineEndIndex ||\n                            currentLineEndIndex === -1)\n                    ) {\n                        const argumentsContent = extractWithinBrackets(\n                            inputText,\n                            nextOpenParenthesisIndex,\n                            \"(\",\n                            \")\"\n                        );\n                        arguments = argumentsContent.content;\n                    }\n\n                    // See if it has a postkeyword\n                    const postkeywordMatch = currentLine.match(\n                        new RegExp(`\\\\s*${topLevelElement.postkeyword}\\\\s+`)\n                    );\n                    if (postkeywordMatch) {\n                        item.postkeyword = topLevelElement.postkeyword;\n                        item.post = currentLine\n                            .substring(\n                                postkeywordMatch.index +\n                                    postkeywordMatch[0].length\n                            )\n                            .trim();\n                    }\n\n                    item.type = topLevelElement.name;\n                    item.name = name.trim();\n                    item.declaredtype = type.trim();\n                    item.annotation = annotation.trim();\n                    item.generic = generic.trim();\n                    item.arguments = arguments.trim();\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                } else {\n                    item.type = topLevelElement.name;\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                }\n            }\n        }\n\n        if (!matched) {\n            // Move to next line\n            if (currentLineEndIndex === -1) {\n                // End of input\n                currentIndex = inputText.length;\n            } else {\n                currentIndex = currentLineEndIndex + 1;\n            }\n        }\n\n        if (currentIndex === -1) {\n            // End of input\n            break;\n        }\n    }\n\n    return results;\n}\n\nmodule.exports = {\n    parse,\n};\n",
      "contentHash": "5a55294a0b8cf6c6277f1c829e69753ece48cbb4b80a27de63f5f9935a71a6e4",
      "noWriteIfExists": false
    },
    {
      "filename": "src/pages-lang.parser.js",
      "content": "const TOP_LEVEL_ELEMENTS = [\n    {\n        type: \"block\",\n        name: \"dashboard_block\",\n        keyword: \"dashboard\",\n        content: [\n            {\n                type: \"property\",\n                name: \"title\",\n                keyword: \"title\",\n            },\n            {\n                type: \"property\",\n                name: \"message\",\n                keyword: \"message\",\n            },\n            {\n                type: \"declaration\",\n                name: \"pre_action\",\n                keyword: \"pre action\",\n                postkeyword: \"goes to\",\n            },\n            {\n                type: \"declaration\",\n                name: \"post_action\",\n                keyword: \"post action\",\n                postkeyword: \"goes to\",\n            },\n            {\n                type: \"block\",\n                name: \"stat_widget\",\n                keyword: \"stat widget\",\n                content: [],\n            },\n            {\n                type: \"block\",\n                name: \"message_widget\",\n                keyword: \"msg widget\",\n                content: [],\n            },\n            {\n                type: \"block\",\n                name: \"list_widget\",\n                keyword: \"list widget\",\n                content: [\n                    {\n                        type: \"property\",\n                        name: \"item\",\n                        keyword: \"item\",\n                    },\n                ],\n            },\n        ],\n    },\n    {\n        type: \"block\",\n        name: \"list_page_block\",\n        keyword: \"list_page\",\n        content: [\n            {\n                type: \"property\",\n                name: \"title\",\n                keyword: \"title\",\n            },\n            {\n                type: \"property\",\n                name: \"message\",\n                keyword: \"message\",\n            },\n            {\n                type: \"typed-declaration\",\n                name: \"column\",\n                keyword: \"column\",\n                postkeyword: \"example\",\n            },\n            {\n                type: \"declaration\",\n                name: \"pre_action\",\n                keyword: \"pre action\",\n                postkeyword: \"goes to\",\n            },\n            {\n                type: \"declaration\",\n                name: \"post_action\",\n                keyword: \"post action\",\n                postkeyword: \"goes to\",\n            },\n            {\n                type: \"declaration\",\n                name: \"item_action\",\n                keyword: \"item action\",\n                postkeyword: \"goes to\",\n            },\n        ],\n    },\n    {\n        type: \"block\",\n        name: \"edit_page_block\",\n        keyword: \"edit_page\",\n        content: [\n            {\n                type: \"property\",\n                name: \"title\",\n                keyword: \"title\",\n            },\n            {\n                type: \"property\",\n                name: \"message\",\n                keyword: \"message\",\n            },\n            {\n                type: \"typed-declaration\",\n                name: \"field\",\n                keyword: \"field\",\n                postkeyword: \"example\",\n            },\n            {\n                type: \"declaration\",\n                name: \"pre_action\",\n                keyword: \"pre action\",\n                postkeyword: \"goes to\",\n            },\n            {\n                type: \"declaration\",\n                name: \"post_action\",\n                keyword: \"post action\",\n                postkeyword: \"goes to\",\n            },\n        ],\n    },\n];\n\n// Helper functions\nfunction extractWithinBrackets(text, startIndex, openChar, closeChar) {\n    let content = \"\";\n    let bracketCount = 0;\n    let foundStart = false;\n\n    for (let i = startIndex; i < text.length; i++) {\n        let char = text[i];\n        if (!foundStart) {\n            if (char === openChar) {\n                foundStart = true;\n                bracketCount++;\n            }\n        } else {\n            content += char;\n            if (char === openChar) bracketCount++;\n            if (char === closeChar) bracketCount--;\n            if (bracketCount === 0) {\n                return {\n                    content: content.substring(0, content.length - 1).trim(),\n                    endIndex: i,\n                };\n            }\n        }\n    }\n    return null; // No matching closing bracket found\n}\n\nfunction parse(inputText, topLevelElements = TOP_LEVEL_ELEMENTS) {\n    // There are 4 fundamental structures to parse:\n    // type: block\n    //   The general syntax of blocks is:\n    //     KEYWORD NAME [ ANNOTATION ] < GENERIC > ( ARGUMENTS ) { CONTENT }\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   NAME is a single word, or some words. It may also contain '.', '-', '_' or '#'.\n    //   ANNOTATION is part of a block, surrounded by '[' and ']'. It is arbitrary text between the block characters.\n    //   GENERIC is part of a block, surrounded by '<' and '>'. It is arbitrary text between the block characters.\n    //   ARGUMENTS is part of a block, surrounded by '(' and ')'. It is arbitrary text between the block characters.\n    //   CONTENT is part of a block, surrounded by '{' and '}'. It is arbitrary text between the block characters.\n    // type: property\n    //   The general syntax of properties is:\n    //     KEYWORD VALUE\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   VALUE is any text, up to the end of the line.\n    // type: typed-declaration\n    //   The general syntax of typed-declarations is:\n    //     KEYWORD NAME [ ANNOTATION ] < GENERIC > ( ARGUMENTS ) : TYPE POSTKEYWORD POST\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   NAME is a single word, or some words. It may also contain '.', '-', '_' or '#'.\n    //   ANNOTATION is part of a typed-declaration, surrounded by '[' and ']'. It is arbitrary text between the block characters.\n    //   GENERIC is part of a typed-declaration, surrounded by '<' and '>'. It is arbitrary text between the block characters.\n    //   ARGUMENTS is part of a typed-declaration, surrounded by '(' and ')'. It is arbitrary text between the block characters.\n    //   TYPE is a single word, or some words. The list of valid types is known and fixed.\n    //   POSTKEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   POST is any text, up to the end of the line.\n    // type: declaration\n    //   The general syntax of declarations is:\n    //     KEYWORD NAME [ ANNOTATION ] < GENERIC > ( ARGUMENTS ) POSTKEYWORD POST\n    //   KEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   NAME is a single word, or some words. It may also contain '.', '-', '_' or '#'.\n    //   ANNOTATION is part of a declaration, surrounded by '[' and ']'. It is arbitrary text between the block characters.\n    //   GENERIC is part of a declaration, surrounded by '<' and '>'. It is arbitrary text between the block characters.\n    //   ARGUMENTS is part of a declaration, surrounded by '(' and ')'. It is arbitrary text between the block characters.\n    //   POSTKEYWORD is always a single word, or some words. The list of valid keywords is known and fixed.\n    //   POST is any text, up to the end of the line.\n    // Comments: Line comments are supported. Any line beginning with '//' is considered a comment. The element starting after one or more comments receives the comment, so it is available for parsing.\n\n    // The parser works like this:\n    //   We have a comment buffer, which is [] by default.\n    //   We have a context (stack), which is created from the top-level elements by default\n    //   We are looking for the first line, that matches a regex in the current context\n    //   Based on the keyword, we decide on the exact type of structure to parse\n    //   In case of blocks ...\n    //     We create a new context from the block, and push it to the stack\n    //     We parse the annotation (if any) ...\n    //       We look for the first '[' character\n    //       We start counting '[' and ']' characters, to find the end of the annotation\n    //       We set ANNOTATION to the trimmed text between the '[' and ']' characters\n    //     We parse the generic (if any) ...\n    //       We look for the first '<' character\n    //       We start counting '<' and '>' characters, to find the end of the generic\n    //       We set GENERIC to the trimmed text between the '<' and '>' characters\n    //     We parse the arguments (if any) ...\n    //       We look for the first '(' character\n    //       We start counting '(' and ')' characters, to find the end of the arguments\n    //       We set ARGUMENTS to the trimmed text between the '(' and ')' characters\n    //     We parse the content (if any) ...\n    //       We look for the first '{' character\n    //       We start counting '{' and '}' characters, to find the end of the content\n    //       We set CONTENT to the trimmed text between the '{' and '}' characters\n    //     We pop the context from the stack\n    //   In case of properties ...\n    //     We parse the value ...\n    //       We set VALUE to the trimmed text after the keyword\n    //   In case of typed-declarations ...\n    //     We parse the annotation (if any) ...\n    //       We look for the first '[' character\n    //       We start counting '[' and ']' characters, to find the end of the annotation\n    //       We set ANNOTATION to the trimmed text between the '[' and ']' characters\n    //     We parse the generic (if any) ...\n    //       We look for the first '<' character\n    //       We start counting '<' and '>' characters, to find the end of the generic\n    //       We set GENERIC to the trimmed text between the '<' and '>' characters\n    //     We parse the arguments (if any) ...\n    //       We look for the first '(' character\n    //       We start counting '(' and ')' characters, to find the end of the arguments\n    //       We set ARGUMENTS to the trimmed text between the '(' and ')' characters\n    //     We parse the type, postkeyword and post parts using a regex\n    //   In case of declarations ...\n    //     We parse the annotation (if any) ...\n    //       We look for the first '[' character\n    //       We start counting '[' and ']' characters, to find the end of the annotation\n    //       We set ANNOTATION to the trimmed text between the '[' and ']' characters\n    //     We parse the generic (if any) ...\n    //       We look for the first '<' character\n    //       We start counting '<' and '>' characters, to find the end of the generic\n    //       We set GENERIC to the trimmed text between the '<' and '>' characters\n    //     We parse the arguments (if any) ...\n    //       We look for the first '(' character\n    //       We start counting '(' and ')' characters, to find the end of the arguments\n    //       We set ARGUMENTS to the trimmed text between the '(' and ')' characters\n    //     We parse the postkeyword and post parts using a regex\n    //   In case of comments ...\n    //     We add the comment to the comment buffer\n    //   In case of empty lines ...\n    //     We ignore the line\n    //   In case of unknown lines ...\n    //     We ignore the line\n\n    let currentIndex = 0;\n    let commentBuffer = [];\n    let results = [];\n\n    while (currentIndex < inputText.length) {\n        const currentLineEndIndex = inputText.indexOf(\"\\n\", currentIndex);\n        if (currentIndex === currentLineEndIndex) {\n            // Empty line\n            currentIndex++;\n            commentBuffer = [];\n            continue;\n        }\n        const currentLine = inputText\n            .substring(\n                currentIndex,\n                currentLineEndIndex === -1\n                    ? inputText.length\n                    : currentLineEndIndex\n            )\n            .trim();\n\n        // Check for comments\n        if (currentLine.startsWith(\"//\")) {\n            commentBuffer.push(currentLine.substring(2).trim());\n            // Move to the next line\n            currentIndex = currentLineEndIndex + 1;\n            continue;\n        }\n\n        const item = { type: \"Unknown\" };\n\n        // Try to match a top level element\n        let matched = false;\n\n        for (let topLevelElement of topLevelElements) {\n            const isThisElement = new RegExp(\n                `^\\\\s*${topLevelElement.keyword}\\\\s+`\n            ).test(currentLine);\n            if (!matched && isThisElement) {\n                if (topLevelElement.type === \"block\") {\n                    // It is a block\n                    // Let's first find where it starts (first '{' character)\n                    const blockStartIndex = inputText.indexOf(\n                        \"{\",\n                        currentIndex\n                    );\n                    if (blockStartIndex === -1) {\n                        // No block start found\n                        break;\n                    }\n                    const blockContent = extractWithinBrackets(\n                        inputText,\n                        blockStartIndex,\n                        \"{\",\n                        \"}\"\n                    );\n\n                    // We should now find the name from the current line\n                    const nameMatch = currentLine.match(\n                        new RegExp(\n                            `\\\\s*${topLevelElement.keyword}\\\\s+([a-zA-Z0-9_\\\\-#\\\\. ]+)(?:[\\\\[\\\\(<{])`\n                        )\n                    );\n                    const name = nameMatch ? nameMatch[1] : null;\n\n                    // Now let's see if the block has annotations\n                    // We need to check between currentIndex and blockStartIndex, whether there's a '[' character\n                    // If there is, we should extract the annotation\n                    let annotation = \"\";\n                    const nextSquareBracketIndex = inputText.indexOf(\n                        \"[\",\n                        currentIndex\n                    );\n                    if (\n                        nextSquareBracketIndex !== -1 &&\n                        nextSquareBracketIndex < blockStartIndex\n                    ) {\n                        const annotationContent = extractWithinBrackets(\n                            inputText,\n                            nextSquareBracketIndex,\n                            \"[\",\n                            \"]\"\n                        );\n                        annotation = annotationContent.content;\n                    }\n\n                    // Extract generics\n                    let generic = \"\";\n                    const nextLessThanIndex = inputText.indexOf(\n                        \"<\",\n                        currentIndex\n                    );\n                    if (\n                        nextLessThanIndex !== -1 &&\n                        nextLessThanIndex < blockStartIndex\n                    ) {\n                        const genericContent = extractWithinBrackets(\n                            inputText,\n                            nextLessThanIndex,\n                            \"<\",\n                            \">\"\n                        );\n                        generic = genericContent.content;\n                    }\n\n                    // Extract arguments\n                    let arguments = \"\";\n                    const nextOpenParenthesisIndex = inputText.indexOf(\n                        \"(\",\n                        currentIndex\n                    );\n                    if (\n                        nextOpenParenthesisIndex !== -1 &&\n                        nextOpenParenthesisIndex < blockStartIndex\n                    ) {\n                        const argumentsContent = extractWithinBrackets(\n                            inputText,\n                            nextOpenParenthesisIndex,\n                            \"(\",\n                            \")\"\n                        );\n                        arguments = argumentsContent.content;\n                    }\n\n                    // Now we parse the content\n                    const parsedBlockContent = parse(\n                        blockContent.content,\n                        topLevelElement.content || []\n                    );\n\n                    item.type = topLevelElement.name;\n                    item.name = name.trim();\n                    item.annotation = annotation.trim();\n                    item.generic = generic.trim();\n                    item.arguments = arguments.trim();\n                    item.content = parsedBlockContent;\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    // Add item to results\n                    results.push(item);\n                    matched = true;\n\n                    // Now we move to the line after the block\n                    currentIndex = blockContent.endIndex + 1;\n                } else if (topLevelElement.type === \"property\") {\n                    item.type = topLevelElement.name;\n                    item.value = currentLine\n                        .substring(topLevelElement.keyword.length)\n                        .trim();\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                } else if (topLevelElement.type === \"declaration\") {\n                    // We should now find the name from the current line\n                    const nameMatch = currentLine.match(\n                        new RegExp(\n                            `\\\\s*${topLevelElement.keyword}\\\\s+([a-zA-Z0-9_\\\\-#\\\\. ]+)(?:[\\\\[\\\\(<{])`\n                        )\n                    );\n                    const name = nameMatch ? nameMatch[1] : null;\n\n                    // Now let's see if the declaration has annotations in the current line\n                    // We need to check between currentIndex and currentLineEndIndex, whether there's a '[' character\n                    // If there is, we should extract the annotation\n                    let annotation = \"\";\n                    const nextSquareBracketIndex = inputText.indexOf(\n                        \"[\",\n                        currentIndex\n                    );\n                    if (\n                        nextSquareBracketIndex !== -1 &&\n                        (nextSquareBracketIndex < currentLineEndIndex ||\n                            currentLineEndIndex === -1)\n                    ) {\n                        const annotationContent = extractWithinBrackets(\n                            inputText,\n                            nextSquareBracketIndex,\n                            \"[\",\n                            \"]\"\n                        );\n                        annotation = annotationContent.content;\n                    }\n\n                    // Extract generics\n                    let generic = \"\";\n                    const nextLessThanIndex = inputText.indexOf(\n                        \"<\",\n                        currentIndex\n                    );\n                    if (\n                        nextLessThanIndex !== -1 &&\n                        (nextLessThanIndex < currentLineEndIndex ||\n                            currentLineEndIndex === -1)\n                    ) {\n                        const genericContent = extractWithinBrackets(\n                            inputText,\n                            nextLessThanIndex,\n                            \"<\",\n                            \">\"\n                        );\n                        generic = genericContent.content;\n                    }\n\n                    // Extract arguments\n                    let arguments = \"\";\n                    const nextOpenParenthesisIndex = inputText.indexOf(\n                        \"(\",\n                        currentIndex\n                    );\n                    if (\n                        nextOpenParenthesisIndex !== -1 &&\n                        (nextOpenParenthesisIndex < currentLineEndIndex ||\n                            currentLineEndIndex === -1)\n                    ) {\n                        const argumentsContent = extractWithinBrackets(\n                            inputText,\n                            nextOpenParenthesisIndex,\n                            \"(\",\n                            \")\"\n                        );\n                        arguments = argumentsContent.content;\n                    }\n\n                    // See if it has a postkeyword\n                    const postkeywordMatch = currentLine.match(\n                        new RegExp(`\\\\s*${topLevelElement.postkeyword}\\\\s+`)\n                    );\n                    if (postkeywordMatch) {\n                        item.postkeyword = topLevelElement.postkeyword;\n                        item.post = currentLine\n                            .substring(\n                                postkeywordMatch.index +\n                                    postkeywordMatch[0].length\n                            )\n                            .trim();\n                    }\n\n                    item.type = topLevelElement.name;\n                    item.name = name.trim();\n                    item.annotation = annotation.trim();\n                    item.generic = generic.trim();\n                    item.arguments = arguments.trim();\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                } else if (topLevelElement.type === \"typed-declaration\") {\n                    // We should now find the name from the current line\n                    const nameMatch = currentLine.match(\n                        new RegExp(\n                            `\\\\s*${topLevelElement.keyword}\\\\s+([a-zA-Z0-9_\\\\-#\\\\. ]+)(?:[\\\\[\\\\(<{])?\\\\s*:\\\\s*`\n                        )\n                    );\n                    const name = nameMatch ? nameMatch[1] : null;\n\n                    // Now we should find the type declaration\n                    const typeMatch = currentLine.match(\n                        /\\s*:\\s*([\\w]+)(?:\\s+)?/\n                    );\n                    const type = typeMatch ? typeMatch[1] : null;\n\n                    // Now let's see if the block has annotations\n                    // We need to check between currentIndex and blockStartIndex, whether there's a '[' character\n                    // If there is, we should extract the annotation\n                    let annotation = \"\";\n                    const nextSquareBracketIndex = inputText.indexOf(\n                        \"[\",\n                        currentIndex\n                    );\n                    if (\n                        nextSquareBracketIndex !== -1 &&\n                        (nextSquareBracketIndex < currentLineEndIndex ||\n                            currentLineEndIndex === -1)\n                    ) {\n                        const annotationContent = extractWithinBrackets(\n                            inputText,\n                            nextSquareBracketIndex,\n                            \"[\",\n                            \"]\"\n                        );\n                        annotation = annotationContent.content;\n                    }\n\n                    // Extract generics\n                    let generic = \"\";\n                    const nextLessThanIndex = inputText.indexOf(\n                        \"<\",\n                        currentIndex\n                    );\n                    if (\n                        nextLessThanIndex !== -1 &&\n                        (nextLessThanIndex < currentLineEndIndex ||\n                            currentLineEndIndex === -1)\n                    ) {\n                        const genericContent = extractWithinBrackets(\n                            inputText,\n                            nextLessThanIndex,\n                            \"<\",\n                            \">\"\n                        );\n                        generic = genericContent.content;\n                    }\n\n                    // Extract arguments\n                    let arguments = \"\";\n                    const nextOpenParenthesisIndex = inputText.indexOf(\n                        \"(\",\n                        currentIndex\n                    );\n                    if (\n                        nextOpenParenthesisIndex !== -1 &&\n                        (nextOpenParenthesisIndex < currentLineEndIndex ||\n                            currentLineEndIndex === -1)\n                    ) {\n                        const argumentsContent = extractWithinBrackets(\n                            inputText,\n                            nextOpenParenthesisIndex,\n                            \"(\",\n                            \")\"\n                        );\n                        arguments = argumentsContent.content;\n                    }\n\n                    // See if it has a postkeyword\n                    const postkeywordMatch = currentLine.match(\n                        new RegExp(`\\\\s*${topLevelElement.postkeyword}\\\\s+`)\n                    );\n                    if (postkeywordMatch) {\n                        item.postkeyword = topLevelElement.postkeyword;\n                        item.post = currentLine\n                            .substring(\n                                postkeywordMatch.index +\n                                    postkeywordMatch[0].length\n                            )\n                            .trim();\n                    }\n\n                    item.type = topLevelElement.name;\n                    item.name = name.trim();\n                    item.declaredtype = type.trim();\n                    item.annotation = annotation.trim();\n                    item.generic = generic.trim();\n                    item.arguments = arguments.trim();\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                } else {\n                    item.type = topLevelElement.name;\n\n                    item.comment = commentBuffer.join(\"\\n\");\n                    commentBuffer = [];\n\n                    results.push(item);\n                    matched = true;\n\n                    // Move to next line\n                    if (currentLineEndIndex === -1) {\n                        // End of input\n                        currentIndex = inputText.length;\n                    } else {\n                        currentIndex = currentLineEndIndex + 1;\n                    }\n                }\n            }\n        }\n\n        if (!matched) {\n            // Move to next line\n            if (currentLineEndIndex === -1) {\n                // End of input\n                currentIndex = inputText.length;\n            } else {\n                currentIndex = currentLineEndIndex + 1;\n            }\n        }\n\n        if (currentIndex === -1) {\n            // End of input\n            break;\n        }\n    }\n\n    return results;\n}\n\nmodule.exports = {\n    parse,\n};\n",
      "contentHash": "2c42e4fbc0a1eaf653fcd9fa3374d260c3e2af085ddc934090274712e05bd045",
      "noWriteIfExists": false
    },
    {
      "filename": "test/test-entity-lang.js",
      "content": "const { parse } = require(\"../src/entity-lang.parser\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst examplePath = path.join(__dirname, \"../examples/test.entities\");\nconst testContent = fs.readFileSync(examplePath, \"utf8\");\nconst parsedContent = parse(testContent);\n\nconsole.log(JSON.stringify(parsedContent, null, 4));\n",
      "contentHash": "7ae0647920e5f14989b0f2389b9828dc05c18d9dedafa8dedf9ae1a77120cd15",
      "noWriteIfExists": false
    },
    {
      "filename": "test/test-pages-lang.js",
      "content": "const { parse } = require(\"../src/pages-lang.parser\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst examplePath = path.join(__dirname, \"../examples/test.pages\");\nconst testContent = fs.readFileSync(examplePath, \"utf8\");\nconst parsedContent = parse(testContent);\n\nconsole.log(JSON.stringify(parsedContent, null, 4));\n",
      "contentHash": "bd0f5766522bded9cc825511e4e43968e3ba788fe287dfdf54ec2b4f56456e55",
      "noWriteIfExists": false
    }
  ]
}